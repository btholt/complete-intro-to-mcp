<!DOCTYPE html><html><head><meta charSet="utf-8" data-next-head=""/><meta name="viewport" content="width=device-width" data-next-head=""/><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png" data-next-head=""/><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png" data-next-head=""/><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png" data-next-head=""/><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png" data-next-head=""/><link rel="icon" type="image/x-icon" href="/images/favicon.ico" data-next-head=""/><title data-next-head="">My First MCP Server – Complete Intro to MCP</title><meta name="description" content="Brian Holt guides you through building a local MCP server (Model Context Protocol) using stdio transport, registering an addition tool with Zod validation, and testing via CLI with JSON RPC 2.0. This hands-on example uses the @modelcontextprotocol/sdk in Node.js to show how MCP servers communicate over standard input/output, laying the groundwork for future SSE-based transports and AI tool integration." data-next-head=""/><meta name="keywords" content="MCP server,Model Context Protocol,JSON RPC 2.0,StdioServerTransport,Node.js,Zod,Brian Holt" data-next-head=""/><meta name="og:description" content="Brian Holt guides you through building a local MCP server (Model Context Protocol) using stdio transport, registering an addition tool with Zod validation, and testing via CLI with JSON RPC 2.0. This hands-on example uses the @modelcontextprotocol/sdk in Node.js to show how MCP servers communicate over standard input/output, laying the groundwork for future SSE-based transports and AI tool integration." data-next-head=""/><meta name="og:title" content="My First MCP Server – Complete Intro to MCP" data-next-head=""/><meta name="og:image" content="/images/social-share-cover.jpg" data-next-head=""/><meta name="twitter:card" content="summary_large_image" data-next-head=""/><link data-next-font="size-adjust" rel="preconnect" href="/" crossorigin="anonymous"/><link rel="preload" href="/_next/static/css/086f6a648d0d9276.css" as="style"/><link rel="stylesheet" href="/_next/static/css/086f6a648d0d9276.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" noModule="" src="/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/_next/static/chunks/webpack-b66ed8ba6f029a99.js" defer=""></script><script src="/_next/static/chunks/framework-2f335d22a7318891.js" defer=""></script><script src="/_next/static/chunks/main-00b4e1227fd2aa8a.js" defer=""></script><script src="/_next/static/chunks/pages/_app-b9f8acf1434dd4b3.js" defer=""></script><script src="/_next/static/chunks/pages/lessons/%5Bsection%5D/%5Bslug%5D-2115f22e4e476f99.js" defer=""></script><script src="/_next/static/G_slUKxNBRf2cik66oGLY/_buildManifest.js" defer=""></script><script src="/_next/static/G_slUKxNBRf2cik66oGLY/_ssgManifest.js" defer=""></script></head><body><script async="" defer="" src="https://a.holt.courses/latest.js"></script><div id="__next"><div class="remix-app"><header class="navbar"><h1 class="navbar-brand"><a href="/">Complete Intro to MCP</a></h1><div class="navbar-info"><a href="https://frontendmasters.com/courses/mcp/" class="cta-btn">Watch on Frontend Masters</a></div></header><div class="content-container"><div class="main"><div class="lesson-container"><div class="lesson"><div class="lesson-content"><p>Without further ado, let&#39;s make our first MCP server!</p>
<blockquote>
<p>We are going to make a local MCP server first, the &quot;old way&quot;, or the STDIO way, however you want to label it. We&#39;ll do the SSE or the remote way later in the course.</p>
</blockquote>
<p>At its most simple, an MCP server is just that, a server. It runs a locally running server that allows you to feed it information via <a href="https://btholt.github.io/complete-intro-to-linux-and-the-cli/streams-and-pipes">standard IO</a> an LLM can call. In truth, MCP servers are at their core super simple, and you&#39;ll probably think it&#39;s silly that we wrap them in such a mystique (it is silly.)</p>
<p>It&#39;s a bit of a specialized server as it expects certain input to return certain shapes of responses, but beyond that it&#39;s a bog-standard server, so much so that you can literally write your MCP servers in plain Node.js/Bun/Python/whatever.</p>
<p>We&#39;ll be using <code>@modelcontextprotocol/sdk</code> which is a little toolkit that helps you get started. It&#39;s not totally necessary as the MCP protocol is fairly simple but it just helps us make sure that everything gets tracked the right way.</p>
<p>So create a new directory, do <code>npm init -y</code> and run <code>npm install @modelcontextprotocol/sdk</code>. In a new file called mcp.js, add</p>
<pre><code class="hljs language-javascript"><button class="copy-btn">Copy</button><span class="hljs-keyword">import</span> {
  <span class="hljs-title class_">McpServer</span>,
  <span class="hljs-title class_">ResourceTemplate</span>,
} <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@modelcontextprotocol/sdk/server/mcp.js&quot;</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">StdioServerTransport</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@modelcontextprotocol/sdk/server/stdio.js&quot;</span>;
<span class="hljs-keyword">import</span> { z } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;zod&quot;</span>;

<span class="hljs-comment">// Create an MCP server</span>
<span class="hljs-keyword">const</span> server = <span class="hljs-keyword">new</span> <span class="hljs-title class_">McpServer</span>({
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;add-server&quot;</span>,
  <span class="hljs-attr">version</span>: <span class="hljs-string">&quot;1.0.0&quot;</span>,
});

<span class="hljs-comment">// Add an addition tool</span>
server.<span class="hljs-title function_">registerTool</span>(
  <span class="hljs-string">&quot;add&quot;</span>,
  {
    <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Addition Tool&quot;</span>,
    <span class="hljs-attr">description</span>: <span class="hljs-string">&quot;Add two numbers&quot;</span>,
    <span class="hljs-attr">inputSchema</span>: { <span class="hljs-attr">a</span>: z.<span class="hljs-title function_">number</span>(), <span class="hljs-attr">b</span>: z.<span class="hljs-title function_">number</span>() },
  },
  <span class="hljs-title function_">async</span> ({ a, b }) =&gt; {
    <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">content</span>: [{ <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;text&quot;</span>, <span class="hljs-attr">text</span>: <span class="hljs-title class_">String</span>(a + b) }],
    }
  }
);

<span class="hljs-comment">// Start receiving messages on stdin and sending messages on stdout</span>
<span class="hljs-keyword">const</span> transport = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StdioServerTransport</span>();
<span class="hljs-keyword">await</span> server.<span class="hljs-title function_">connect</span>(transport);
</code></pre><ul>
<li>This is as simple an MCP server as you&#39;re going to find.</li>
<li>It registers itself as an MCP server with the <code>new McpServer</code> instantiation</li>
<li>We then add one tool to it, one that adds two numbers together. Obviously an LLM can do this but we&#39;re just going for simple here.</li>
<li>We then specify the transport we&#39;re using is stdio, which is using bash&#39;s stdin to send info to the MCP server. SSE would be the other kind of transport, and we&#39;ll get to that.</li>
<li>We&#39;re also using <a href="https://zod.dev/">Zod</a> here. Zod is a validation library that&#39;s built TypeScript first. It&#39;s really useful as you can define what schemas are expected and it serves several purposes.<ul>
<li>It tells the LLM in strong terms &quot;whatever you give here, it must pass this zod validation. LLMs do well with strong guidelines</li>
<li>It&#39;s documentation for future you of what this tool call needs.</li>
<li>It also allows you to add annotations that tell the LLM &quot;this variable named X expects Y type and in plain English, this variable is Z.&quot;</li>
</ul>
</li>
</ul>
<p>So try starting your server and you&#39;ll see it&#39;ll just do nothing. That&#39;s because you need to use stdin to send it commands! Let&#39;s try one.</p>
<pre><code class="hljs language-bash"><button class="copy-btn">Copy</button><span class="hljs-comment"># List available tools:</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;{&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;id&quot;: 1, &quot;method&quot;: &quot;tools/list&quot;, &quot;params&quot;: {&quot;name&quot;: &quot;add&quot;, &quot;arguments&quot;: {}}}&#x27;</span> | node mcp.js | jq

<span class="hljs-comment"># Call a tool:</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;{&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;id&quot;: 1, &quot;method&quot;: &quot;tools/call&quot;, &quot;params&quot;: {&quot;name&quot;: &quot;add&quot;, &quot;arguments&quot;: {&quot;a&quot;: 5, &quot;b&quot;: 3}}}&#x27;</span> | node mcp.js
</code></pre><ul>
<li><a href="https://jqlang.org/">jq</a> is super helpful for processing JSON on the command line. It can do a lot more than pretty print but it&#39;s 99.99% of what I use it for</li>
<li>You don&#39;t really need to know how to invoke your MCP server via the CLI - your LLM will do it for you. But it helpful for testing! I usually have an LLM write the CLI command for me anyway ♻️</li>
<li>It&#39;s enough to know that you&#39;re calling the tools via stdin with a standard format. It passes that it wants to list available tools (which is how LLMs know what is available to use) and then it uses <code>tools/call</code> to actually invoke the tool. There&#39;s a lot more to MCP but frankly it&#39;s low level and really not needed to be known by you. But this is the protocol.</li>
</ul>
<h2>JSON RPC 2.0</h2>
<p>You should see the MCP server respond with an answer of 8! This feels just like writing API endpoints, but the advantage here is that we get to give these tools to LLMs and they can call into code we generate for them. Let&#39;s talk a bit about JSON RPC 2.0 which is all this is. <a href="https://en.wikipedia.org/wiki/JSON-RPC">JSON RPC</a> is ancient in computing terms with the first version of the spec coming out in 2005. The revised 2.0 version came out in 2010 and that&#39;s what this is using – we&#39;re not doing anything wild here, just relying on a very proven set of technology.</p>
<p>So what <em>is</em> JSON RPC? You can think of it as an alternative to REST. With REST you call endpoints that are based around a thing - e.g. you call a PATCH to /users/123 to update user 123. Your URLs are based things and the semantics of manipulating those things. JSON RPC (and XML RPC before it) is based around calling remote functions - that&#39;s it. It&#39;s literally a remote procedure call. So in this we&#39;re just giving an MCP server direction on what procedures (or functions) we want them to do. That&#39;s it!</p>
<p>Let&#39;s see it initialize itself!</p>
<pre><code class="hljs language-bash"><button class="copy-btn">Copy</button><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;{&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;id&quot;: 1, &quot;method&quot;: &quot;initialize&quot;, &quot;params&quot;: {&quot;protocolVersion&quot;: &quot;2024-11-05&quot;, &quot;capabilities&quot;: {}, &quot;clientInfo&quot;: {&quot;name&quot;: &quot;test-client&quot;, &quot;version&quot;: &quot;1.0.0&quot;}}}&#x27;</span> | node mcp.js | jq
</code></pre></div><div class="lesson-links"><a href="/lessons/setup-mcp-clients/other-clients" class="prev">← Previous</a><a href="/lessons/lets-build-mcp/using-our-first-mcp-server" class="next">Next →</a></div></div><div class="details-bg"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="154" height="154" viewBox="0 0 154 154"><defs><clipPath id="clip-path"><rect id="Rectangle_2238" data-name="Rectangle 2238" width="154" height="154" transform="translate(9467 350)" fill="#fff" stroke="#707070" stroke-width="1"></rect></clipPath><clipPath id="clip-corner-image-active"><rect width="154" height="154"></rect></clipPath></defs><g id="corner-image-active" clip-path="url(#clip-corner-image-active)"><g id="Corner-image-active-2" data-name="Corner-image-active" transform="translate(-9467 -350)" clip-path="url(#clip-path)"><path id="Subtraction_34" data-name="Subtraction 34" d="M-3857.365,1740.766h0l-7.07-7.07,12.89-12.89v14.142l-5.818,5.818Zm-14.142-14.142h0l-7.071-7.07,27.033-27.033v14.143l-19.96,19.96Zm-14.143-14.143h0l-7.07-7.069,41.175-41.175v14.142Zm-14.142-14.142h0l-7.07-7.069,55.317-55.317v14.142Zm-14.142-14.142h0l-7.07-7.069,69.459-69.459v14.142Zm-14.142-14.142h0l-7.07-7.069,76.739-76.739h6.862v7.28Zm-14.143-14.143h0l-7.07-7.069,62.6-62.6h14.142Zm-14.142-14.142h0l-7.07-7.069,48.454-48.454h14.142Zm-14.142-14.142h0l-7.07-7.069,34.312-34.312h14.142Zm-14.142-14.142h0l-7.07-7.069,20.17-20.17h14.142Zm-14.142-14.142h0l-7.071-7.071,6.027-6.027h14.144l-13.1,13.1Zm367.24-56.114v-.909l.455.455-.453.453Z" transform="translate(13472.546 -1236.766)" fill="var(--corner-fill)"></path></g></g></svg></div></div></div></div><noscript><img src="https://a.holt.courses/noscript.gif" alt="" referrerPolicy="no-referrer-when-downgrade"/></noscript><footer class="footer"><ul class="socials"><li class="social"><a href="https://twitter.com/holtbt"><svg fill="none" height="100%" width="32" xmlns="http://www.w3.org/2000/svg" viewBox="0.254 0.25 500 451.95400000000006"><path d="M394.033.25h76.67L303.202 191.693l197.052 260.511h-154.29L225.118 294.205 86.844 452.204H10.127l179.16-204.77L.254.25H158.46l109.234 144.417zm-26.908 406.063h42.483L135.377 43.73h-45.59z" fill="var(--footer-icons)"></path></svg></a></li><li class="social"><a href="https://bsky.app/profile/brianholt.me"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 -3.268 64 68.414" width="38" height="100%"><path fill="var(--footer-icons)" d="M13.873 3.805C21.21 9.332 29.103 20.537 32 26.55v15.882c0-.338-.13.044-.41.867-1.512 4.456-7.418 21.847-20.923 7.944-7.111-7.32-3.819-14.64 9.125-16.85-7.405 1.264-15.73-.825-18.014-9.015C1.12 23.022 0 8.51 0 6.55 0-3.268 8.579-.182 13.873 3.805zm36.254 0C42.79 9.332 34.897 20.537 32 26.55v15.882c0-.338.13.044.41.867 1.512 4.456 7.418 21.847 20.923 7.944 7.111-7.32 3.819-14.64-9.125-16.85 7.405 1.264 15.73-.825 18.014-9.015C62.88 23.022 64 8.51 64 6.55c0-9.818-8.578-6.732-13.873-2.745z"></path></svg></a></li><li class="social"><a href="https://github.com/btholt"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="32" height="32" viewBox="0 0 32 32"><defs><clipPath id="clip-github-social"><rect width="32" height="32"></rect></clipPath></defs><g id="github-social" clip-path="url(#clip-github-social)"><g id="Group_272" data-name="Group 272" transform="translate(13522.5 -6994)"><path id="Subtraction_33" data-name="Subtraction 33" d="M-24967.5,8041a15.9,15.9,0,0,1-11.312-4.688A15.893,15.893,0,0,1-24983.5,8025a15.893,15.893,0,0,1,4.689-11.315A15.894,15.894,0,0,1-24967.5,8009a15.894,15.894,0,0,1,11.313,4.686A15.893,15.893,0,0,1-24951.5,8025a15.893,15.893,0,0,1-4.689,11.313A15.9,15.9,0,0,1-24967.5,8041Zm-3.781-4.571h0v3.918h7.895v-6.665a1.836,1.836,0,0,0-1.2-1.718c5.1-.617,7.467-2.975,7.467-7.424a7.176,7.176,0,0,0-1.637-4.728,6.74,6.74,0,0,0,.275-1.812,4.34,4.34,0,0,0-.52-2.452.574.574,0,0,0-.359-.1c-1.061,0-3.465,1.411-3.936,1.694a16.644,16.644,0,0,0-4.2-.489,16.379,16.379,0,0,0-3.969.445c-.846-.5-2.91-1.649-3.859-1.649a.566.566,0,0,0-.354.095,4.3,4.3,0,0,0-.521,2.452,6.7,6.7,0,0,0,.244,1.718,7.346,7.346,0,0,0-1.6,4.822,7.263,7.263,0,0,0,1.533,4.985c1.193,1.359,3.115,2.165,5.871,2.464a1.826,1.826,0,0,0-1.129,1.693v.5h0l-.006,0a7.121,7.121,0,0,1-2.033.363,2.608,2.608,0,0,1-.965-.158,4.438,4.438,0,0,1-1.836-1.881,2.361,2.361,0,0,0-1.248-1.091,3.472,3.472,0,0,0-1.217-.3.584.584,0,0,0-.545.224.282.282,0,0,0,.027.367,1.875,1.875,0,0,0,.447.307,4.732,4.732,0,0,1,.561.355,10.726,10.726,0,0,1,1.682,2.755c.043.092.078.163.105.217a3.876,3.876,0,0,0,2.42,1.185,6.036,6.036,0,0,0,.607.025c.875,0,1.988-.124,2-.125Z" transform="translate(11461 -1015)" fill="var(--footer-icons)"></path><g id="Ellipse_670" data-name="Ellipse 670" transform="translate(-13522.5 6994)" fill="none" stroke="var(--footer-icons)" stroke-width="1"><circle cx="16" cy="16" r="16" stroke="none"></circle><circle cx="16" cy="16" r="15.5" fill="none"></circle></g></g></g></svg></a></li><li class="social"><a href="https://linkedin.com/in/btholt"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="32" height="32" viewBox="0 0 32 32"><defs><clipPath id="clip-linkedin-social"><rect width="32" height="32"></rect></clipPath></defs><g id="linkedin-social" clip-path="url(#clip-linkedin-social)"><g id="Group_270" data-name="Group 270" transform="translate(-86.349 -633.073)"><path id="Path_375" data-name="Path 375" d="M115.789,633.073a2.324,2.324,0,0,1,1.682.676,2.194,2.194,0,0,1,.695,1.627V662.8a2.131,2.131,0,0,1-.695,1.609,2.314,2.314,0,0,1-1.646.659H88.69a2.307,2.307,0,0,1-1.646-.659,2.128,2.128,0,0,1-.695-1.609V635.376a2.19,2.19,0,0,1,.695-1.627,2.322,2.322,0,0,1,1.682-.676h27.063Zm-20.224,9.672a2.561,2.561,0,0,0,0-3.584,2.658,2.658,0,0,0-1.938-.712,2.724,2.724,0,0,0-1.957.712,2.371,2.371,0,0,0-.75,1.792,2.4,2.4,0,0,0,.731,1.792,2.605,2.605,0,0,0,1.9.713h.037A2.7,2.7,0,0,0,95.565,642.745ZM96,645.434H91.213V659.88H96Zm17.3,6.144a7.007,7.007,0,0,0-1.573-4.9,5.68,5.68,0,0,0-6.839-.769,5.663,5.663,0,0,0-1.426,1.573v-2.048H98.674q.036.841,0,7.717v6.728h4.791V651.8a3.592,3.592,0,0,1,.146-1.17,2.913,2.913,0,0,1,.878-1.206,2.429,2.429,0,0,1,1.609-.549,2.108,2.108,0,0,1,1.865.914,4.265,4.265,0,0,1,.549,2.341v7.752H113.3Z" fill="var(--footer-icons)"></path></g></g></svg></a></li><li class="social"><div class="terms"><p>Content Licensed Under CC-BY-NC-4.0</p><p>Code Samples and Exercises Licensed Under Apache 2.0</p><p>Site Designed by<!-- --> <a href="https://www.alexdanielson.com/">Alex Danielson</a></p></div></li></ul><div class="theme-icons"><button aria-label="Activate dark mode" title="Activate dark mode" class="theme-toggle"><svg xmlns="http://www.w3.org/2000/svg" width="36px" height="100%" viewBox="0 -960 960 960" fill="var(--text-footer)" role="img"><title>Dark Mode Icon</title><path d="M480-120q-150 0-255-105T120-480q0-150 105-255t255-105q14 0 27.5 1t26.5 3q-41 29-65.5 75.5T444-660q0 90 63 153t153 63q55 0 101-24.5t75-65.5q2 13 3 26.5t1 27.5q0 150-105 255T480-120Zm0-80q88 0 158-48.5T740-375q-20 5-40 8t-40 3q-123 0-209.5-86.5T364-660q0-20 3-40t8-40q-78 32-126.5 102T200-480q0 116 82 198t198 82Z"></path></svg></button></div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"attributes":{"title":"My First MCP Server","description":"Brian Holt guides you through building a local MCP server (Model Context Protocol) using stdio transport, registering an addition tool with Zod validation, and testing via CLI with JSON RPC 2.0. This hands-on example uses the @modelcontextprotocol/sdk in Node.js to show how MCP servers communicate over standard input/output, laying the groundwork for future SSE-based transports and AI tool integration.","keywords":["MCP server","Model Context Protocol","JSON RPC 2.0","StdioServerTransport","Node.js","Zod","Brian Holt"]},"html":"\u003cp\u003eWithout further ado, let\u0026#39;s make our first MCP server!\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eWe are going to make a local MCP server first, the \u0026quot;old way\u0026quot;, or the STDIO way, however you want to label it. We\u0026#39;ll do the SSE or the remote way later in the course.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eAt its most simple, an MCP server is just that, a server. It runs a locally running server that allows you to feed it information via \u003ca href=\"https://btholt.github.io/complete-intro-to-linux-and-the-cli/streams-and-pipes\"\u003estandard IO\u003c/a\u003e an LLM can call. In truth, MCP servers are at their core super simple, and you\u0026#39;ll probably think it\u0026#39;s silly that we wrap them in such a mystique (it is silly.)\u003c/p\u003e\n\u003cp\u003eIt\u0026#39;s a bit of a specialized server as it expects certain input to return certain shapes of responses, but beyond that it\u0026#39;s a bog-standard server, so much so that you can literally write your MCP servers in plain Node.js/Bun/Python/whatever.\u003c/p\u003e\n\u003cp\u003eWe\u0026#39;ll be using \u003ccode\u003e@modelcontextprotocol/sdk\u003c/code\u003e which is a little toolkit that helps you get started. It\u0026#39;s not totally necessary as the MCP protocol is fairly simple but it just helps us make sure that everything gets tracked the right way.\u003c/p\u003e\n\u003cp\u003eSo create a new directory, do \u003ccode\u003enpm init -y\u003c/code\u003e and run \u003ccode\u003enpm install @modelcontextprotocol/sdk\u003c/code\u003e. In a new file called mcp.js, add\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-javascript\"\u003e\u003cbutton class=\"copy-btn\"\u003eCopy\u003c/button\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e {\n  \u003cspan class=\"hljs-title class_\"\u003eMcpServer\u003c/span\u003e,\n  \u003cspan class=\"hljs-title class_\"\u003eResourceTemplate\u003c/span\u003e,\n} \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026quot;@modelcontextprotocol/sdk/server/mcp.js\u0026quot;\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eStdioServerTransport\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026quot;@modelcontextprotocol/sdk/server/stdio.js\u0026quot;\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { z } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026quot;zod\u0026quot;\u003c/span\u003e;\n\n\u003cspan class=\"hljs-comment\"\u003e// Create an MCP server\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e server = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMcpServer\u003c/span\u003e({\n  \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026quot;add-server\u0026quot;\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eversion\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026quot;1.0.0\u0026quot;\u003c/span\u003e,\n});\n\n\u003cspan class=\"hljs-comment\"\u003e// Add an addition tool\u003c/span\u003e\nserver.\u003cspan class=\"hljs-title function_\"\u003eregisterTool\u003c/span\u003e(\n  \u003cspan class=\"hljs-string\"\u003e\u0026quot;add\u0026quot;\u003c/span\u003e,\n  {\n    \u003cspan class=\"hljs-attr\"\u003etitle\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026quot;Addition Tool\u0026quot;\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003edescription\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026quot;Add two numbers\u0026quot;\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003einputSchema\u003c/span\u003e: { \u003cspan class=\"hljs-attr\"\u003ea\u003c/span\u003e: z.\u003cspan class=\"hljs-title function_\"\u003enumber\u003c/span\u003e(), \u003cspan class=\"hljs-attr\"\u003eb\u003c/span\u003e: z.\u003cspan class=\"hljs-title function_\"\u003enumber\u003c/span\u003e() },\n  },\n  \u003cspan class=\"hljs-title function_\"\u003easync\u003c/span\u003e ({ a, b }) =\u0026gt; {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\n        \u003cspan class=\"hljs-attr\"\u003econtent\u003c/span\u003e: [{ \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026quot;text\u0026quot;\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003etext\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e(a + b) }],\n    }\n  }\n);\n\n\u003cspan class=\"hljs-comment\"\u003e// Start receiving messages on stdin and sending messages on stdout\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e transport = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eStdioServerTransport\u003c/span\u003e();\n\u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e server.\u003cspan class=\"hljs-title function_\"\u003econnect\u003c/span\u003e(transport);\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eThis is as simple an MCP server as you\u0026#39;re going to find.\u003c/li\u003e\n\u003cli\u003eIt registers itself as an MCP server with the \u003ccode\u003enew McpServer\u003c/code\u003e instantiation\u003c/li\u003e\n\u003cli\u003eWe then add one tool to it, one that adds two numbers together. Obviously an LLM can do this but we\u0026#39;re just going for simple here.\u003c/li\u003e\n\u003cli\u003eWe then specify the transport we\u0026#39;re using is stdio, which is using bash\u0026#39;s stdin to send info to the MCP server. SSE would be the other kind of transport, and we\u0026#39;ll get to that.\u003c/li\u003e\n\u003cli\u003eWe\u0026#39;re also using \u003ca href=\"https://zod.dev/\"\u003eZod\u003c/a\u003e here. Zod is a validation library that\u0026#39;s built TypeScript first. It\u0026#39;s really useful as you can define what schemas are expected and it serves several purposes.\u003cul\u003e\n\u003cli\u003eIt tells the LLM in strong terms \u0026quot;whatever you give here, it must pass this zod validation. LLMs do well with strong guidelines\u003c/li\u003e\n\u003cli\u003eIt\u0026#39;s documentation for future you of what this tool call needs.\u003c/li\u003e\n\u003cli\u003eIt also allows you to add annotations that tell the LLM \u0026quot;this variable named X expects Y type and in plain English, this variable is Z.\u0026quot;\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSo try starting your server and you\u0026#39;ll see it\u0026#39;ll just do nothing. That\u0026#39;s because you need to use stdin to send it commands! Let\u0026#39;s try one.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003e\u003cbutton class=\"copy-btn\"\u003eCopy\u003c/button\u003e\u003cspan class=\"hljs-comment\"\u003e# List available tools:\u003c/span\u003e\n\u003cspan class=\"hljs-built_in\"\u003eecho\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;{\u0026quot;jsonrpc\u0026quot;: \u0026quot;2.0\u0026quot;, \u0026quot;id\u0026quot;: 1, \u0026quot;method\u0026quot;: \u0026quot;tools/list\u0026quot;, \u0026quot;params\u0026quot;: {\u0026quot;name\u0026quot;: \u0026quot;add\u0026quot;, \u0026quot;arguments\u0026quot;: {}}}\u0026#x27;\u003c/span\u003e | node mcp.js | jq\n\n\u003cspan class=\"hljs-comment\"\u003e# Call a tool:\u003c/span\u003e\n\u003cspan class=\"hljs-built_in\"\u003eecho\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;{\u0026quot;jsonrpc\u0026quot;: \u0026quot;2.0\u0026quot;, \u0026quot;id\u0026quot;: 1, \u0026quot;method\u0026quot;: \u0026quot;tools/call\u0026quot;, \u0026quot;params\u0026quot;: {\u0026quot;name\u0026quot;: \u0026quot;add\u0026quot;, \u0026quot;arguments\u0026quot;: {\u0026quot;a\u0026quot;: 5, \u0026quot;b\u0026quot;: 3}}}\u0026#x27;\u003c/span\u003e | node mcp.js\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://jqlang.org/\"\u003ejq\u003c/a\u003e is super helpful for processing JSON on the command line. It can do a lot more than pretty print but it\u0026#39;s 99.99% of what I use it for\u003c/li\u003e\n\u003cli\u003eYou don\u0026#39;t really need to know how to invoke your MCP server via the CLI - your LLM will do it for you. But it helpful for testing! I usually have an LLM write the CLI command for me anyway ♻️\u003c/li\u003e\n\u003cli\u003eIt\u0026#39;s enough to know that you\u0026#39;re calling the tools via stdin with a standard format. It passes that it wants to list available tools (which is how LLMs know what is available to use) and then it uses \u003ccode\u003etools/call\u003c/code\u003e to actually invoke the tool. There\u0026#39;s a lot more to MCP but frankly it\u0026#39;s low level and really not needed to be known by you. But this is the protocol.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eJSON RPC 2.0\u003c/h2\u003e\n\u003cp\u003eYou should see the MCP server respond with an answer of 8! This feels just like writing API endpoints, but the advantage here is that we get to give these tools to LLMs and they can call into code we generate for them. Let\u0026#39;s talk a bit about JSON RPC 2.0 which is all this is. \u003ca href=\"https://en.wikipedia.org/wiki/JSON-RPC\"\u003eJSON RPC\u003c/a\u003e is ancient in computing terms with the first version of the spec coming out in 2005. The revised 2.0 version came out in 2010 and that\u0026#39;s what this is using – we\u0026#39;re not doing anything wild here, just relying on a very proven set of technology.\u003c/p\u003e\n\u003cp\u003eSo what \u003cem\u003eis\u003c/em\u003e JSON RPC? You can think of it as an alternative to REST. With REST you call endpoints that are based around a thing - e.g. you call a PATCH to /users/123 to update user 123. Your URLs are based things and the semantics of manipulating those things. JSON RPC (and XML RPC before it) is based around calling remote functions - that\u0026#39;s it. It\u0026#39;s literally a remote procedure call. So in this we\u0026#39;re just giving an MCP server direction on what procedures (or functions) we want them to do. That\u0026#39;s it!\u003c/p\u003e\n\u003cp\u003eLet\u0026#39;s see it initialize itself!\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003e\u003cbutton class=\"copy-btn\"\u003eCopy\u003c/button\u003e\u003cspan class=\"hljs-built_in\"\u003eecho\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;{\u0026quot;jsonrpc\u0026quot;: \u0026quot;2.0\u0026quot;, \u0026quot;id\u0026quot;: 1, \u0026quot;method\u0026quot;: \u0026quot;initialize\u0026quot;, \u0026quot;params\u0026quot;: {\u0026quot;protocolVersion\u0026quot;: \u0026quot;2024-11-05\u0026quot;, \u0026quot;capabilities\u0026quot;: {}, \u0026quot;clientInfo\u0026quot;: {\u0026quot;name\u0026quot;: \u0026quot;test-client\u0026quot;, \u0026quot;version\u0026quot;: \u0026quot;1.0.0\u0026quot;}}}\u0026#x27;\u003c/span\u003e | node mcp.js | jq\n\u003c/code\u003e\u003c/pre\u003e","markdown":"\nWithout further ado, let's make our first MCP server!\n\n\u003e We are going to make a local MCP server first, the \"old way\", or the STDIO way, however you want to label it. We'll do the SSE or the remote way later in the course.\n\nAt its most simple, an MCP server is just that, a server. It runs a locally running server that allows you to feed it information via [standard IO][stdio] an LLM can call. In truth, MCP servers are at their core super simple, and you'll probably think it's silly that we wrap them in such a mystique (it is silly.)\n\nIt's a bit of a specialized server as it expects certain input to return certain shapes of responses, but beyond that it's a bog-standard server, so much so that you can literally write your MCP servers in plain Node.js/Bun/Python/whatever.\n\nWe'll be using `@modelcontextprotocol/sdk` which is a little toolkit that helps you get started. It's not totally necessary as the MCP protocol is fairly simple but it just helps us make sure that everything gets tracked the right way.\n\nSo create a new directory, do `npm init -y` and run `npm install @modelcontextprotocol/sdk`. In a new file called mcp.js, add\n\n```javascript\nimport {\n  McpServer,\n  ResourceTemplate,\n} from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport { z } from \"zod\";\n\n// Create an MCP server\nconst server = new McpServer({\n  name: \"add-server\",\n  version: \"1.0.0\",\n});\n\n// Add an addition tool\nserver.registerTool(\n  \"add\",\n  {\n    title: \"Addition Tool\",\n    description: \"Add two numbers\",\n    inputSchema: { a: z.number(), b: z.number() },\n  },\n  async ({ a, b }) =\u003e {\n    return {\n        content: [{ type: \"text\", text: String(a + b) }],\n    }\n  }\n);\n\n// Start receiving messages on stdin and sending messages on stdout\nconst transport = new StdioServerTransport();\nawait server.connect(transport);\n```\n\n- This is as simple an MCP server as you're going to find.\n- It registers itself as an MCP server with the `new McpServer` instantiation\n- We then add one tool to it, one that adds two numbers together. Obviously an LLM can do this but we're just going for simple here.\n- We then specify the transport we're using is stdio, which is using bash's stdin to send info to the MCP server. SSE would be the other kind of transport, and we'll get to that.\n- We're also using [Zod][zod] here. Zod is a validation library that's built TypeScript first. It's really useful as you can define what schemas are expected and it serves several purposes.\n  - It tells the LLM in strong terms \"whatever you give here, it must pass this zod validation. LLMs do well with strong guidelines\n  - It's documentation for future you of what this tool call needs.\n  - It also allows you to add annotations that tell the LLM \"this variable named X expects Y type and in plain English, this variable is Z.\"\n\nSo try starting your server and you'll see it'll just do nothing. That's because you need to use stdin to send it commands! Let's try one.\n\n```bash\n# List available tools:\necho '{\"jsonrpc\": \"2.0\", \"id\": 1, \"method\": \"tools/list\", \"params\": {\"name\": \"add\", \"arguments\": {}}}' | node mcp.js | jq\n\n# Call a tool:\necho '{\"jsonrpc\": \"2.0\", \"id\": 1, \"method\": \"tools/call\", \"params\": {\"name\": \"add\", \"arguments\": {\"a\": 5, \"b\": 3}}}' | node mcp.js\n```\n\n- [jq][jq] is super helpful for processing JSON on the command line. It can do a lot more than pretty print but it's 99.99% of what I use it for\n- You don't really need to know how to invoke your MCP server via the CLI - your LLM will do it for you. But it helpful for testing! I usually have an LLM write the CLI command for me anyway ♻️\n- It's enough to know that you're calling the tools via stdin with a standard format. It passes that it wants to list available tools (which is how LLMs know what is available to use) and then it uses `tools/call` to actually invoke the tool. There's a lot more to MCP but frankly it's low level and really not needed to be known by you. But this is the protocol.\n\n## JSON RPC 2.0\n\nYou should see the MCP server respond with an answer of 8! This feels just like writing API endpoints, but the advantage here is that we get to give these tools to LLMs and they can call into code we generate for them. Let's talk a bit about JSON RPC 2.0 which is all this is. [JSON RPC][rpc] is ancient in computing terms with the first version of the spec coming out in 2005. The revised 2.0 version came out in 2010 and that's what this is using – we're not doing anything wild here, just relying on a very proven set of technology.\n\nSo what _is_ JSON RPC? You can think of it as an alternative to REST. With REST you call endpoints that are based around a thing - e.g. you call a PATCH to /users/123 to update user 123. Your URLs are based things and the semantics of manipulating those things. JSON RPC (and XML RPC before it) is based around calling remote functions - that's it. It's literally a remote procedure call. So in this we're just giving an MCP server direction on what procedures (or functions) we want them to do. That's it!\n\nLet's see it initialize itself!\n\n```bash\necho '{\"jsonrpc\": \"2.0\", \"id\": 1, \"method\": \"initialize\", \"params\": {\"protocolVersion\": \"2024-11-05\", \"capabilities\": {}, \"clientInfo\": {\"name\": \"test-client\", \"version\": \"1.0.0\"}}}' | node mcp.js | jq\n```\n\n[stdio]: https://btholt.github.io/complete-intro-to-linux-and-the-cli/streams-and-pipes\n[rpc]: https://en.wikipedia.org/wiki/JSON-RPC\n[jq]: https://jqlang.org/\n[zod]: https://zod.dev/\n","slug":"my-first-mcp-server","title":"My First MCP Server","section":"Let's Build an MCP Server","icon":"file-code","filePath":"/home/runner/work/complete-intro-to-mcp/complete-intro-to-mcp/lessons/04-lets-build-mcp/A-my-first-mcp-server.md","nextSlug":"/lessons/lets-build-mcp/using-our-first-mcp-server","prevSlug":"/lessons/setup-mcp-clients/other-clients"}},"__N_SSG":true},"page":"/lessons/[section]/[slug]","query":{"section":"lets-build-mcp","slug":"my-first-mcp-server"},"buildId":"G_slUKxNBRf2cik66oGLY","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>