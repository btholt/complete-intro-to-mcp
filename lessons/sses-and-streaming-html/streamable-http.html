<!DOCTYPE html><html><head><meta charSet="utf-8" data-next-head=""/><meta name="viewport" content="width=device-width" data-next-head=""/><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png" data-next-head=""/><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png" data-next-head=""/><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png" data-next-head=""/><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png" data-next-head=""/><link rel="icon" type="image/x-icon" href="/images/favicon.ico" data-next-head=""/><title data-next-head="">Streamable HTTP – Complete Intro to MCP</title><meta name="description" content="Brian Holt walks you through building a Streamable HTTP MCP server in Node.js with Express, using a single /mcp endpoint and UUID-based sessions for client-server communication. The guide contrasts streamable HTTP with SSEs, demonstrates a concrete MCP setup (POST for client messages, GET for server messages, DELETE to end sessions), and covers scalability and security considerations plus inspector usage." data-next-head=""/><meta name="keywords" content="MCP,Model Context Protocol,Streamable HTTP,Node.js,Express,session management" data-next-head=""/><meta name="og:description" content="Brian Holt walks you through building a Streamable HTTP MCP server in Node.js with Express, using a single /mcp endpoint and UUID-based sessions for client-server communication. The guide contrasts streamable HTTP with SSEs, demonstrates a concrete MCP setup (POST for client messages, GET for server messages, DELETE to end sessions), and covers scalability and security considerations plus inspector usage." data-next-head=""/><meta name="og:title" content="Streamable HTTP – Complete Intro to MCP" data-next-head=""/><meta name="og:image" content="/images/social-share-cover.jpg" data-next-head=""/><meta name="twitter:card" content="summary_large_image" data-next-head=""/><link data-next-font="size-adjust" rel="preconnect" href="/" crossorigin="anonymous"/><link rel="preload" href="/_next/static/css/086f6a648d0d9276.css" as="style"/><link rel="stylesheet" href="/_next/static/css/086f6a648d0d9276.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" noModule="" src="/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/_next/static/chunks/webpack-b66ed8ba6f029a99.js" defer=""></script><script src="/_next/static/chunks/framework-2f335d22a7318891.js" defer=""></script><script src="/_next/static/chunks/main-00b4e1227fd2aa8a.js" defer=""></script><script src="/_next/static/chunks/pages/_app-b9f8acf1434dd4b3.js" defer=""></script><script src="/_next/static/chunks/pages/lessons/%5Bsection%5D/%5Bslug%5D-2115f22e4e476f99.js" defer=""></script><script src="/_next/static/3Mg5_eXgxRUcnLOJp0h8Y/_buildManifest.js" defer=""></script><script src="/_next/static/3Mg5_eXgxRUcnLOJp0h8Y/_ssgManifest.js" defer=""></script></head><body><script async="" defer="" src="https://a.holt.courses/latest.js"></script><div id="__next"><div class="remix-app"><header class="navbar"><h1 class="navbar-brand"><a href="/">Complete Intro to MCP</a></h1><div class="navbar-info"><a href="https://frontendmasters.com/courses/mcp/" class="cta-btn">Watch on Frontend Masters</a></div></header><div class="content-container"><div class="main"><div class="lesson-container"><div class="lesson"><div class="lesson-content"><p>Mark my words, there is about to be a Cambrian explosion of MCP server frameworks for Node.js that will handle a lot of this plumbing for you. But there isn&#39;t yet so we&#39;re going to have to do some manual housekeeping of session data. We&#39;re also not going to implement this in the most scalable way, but I&#39;ll leave that as an exercise to you to do.</p>
<p>So let&#39;s talk about how streamable HTTP is different than SSEs. For one, there&#39;s just the one endpoint - you don&#39;t have to GET to one and POST to the other.</p>
<p><img src="/images/streamable.png" alt="Streamable HTTP diagram"></p>
<p>The topography of handshakes here is a bit more complicated but at the end you get a resumable session, one endpoint to deal with instead of two, and a server that can be stateless as long you architect it well.</p>
<p>But yeah, the key here is that the server gives the session a UUID as a session ID and then the client refers to that using an HTTP header to make sure that the server and client both understand the ongoing context. That&#39;s really it. The idea of SSEs still happen inside of this, but it&#39;s only part of the architecture instead of all of it.</p>
<p>We&#39;re going to implement our MCP main.js again but instead in <code>streamable.js</code> and using Express as our Node.js server. Express is chosen because we really just need minimal HTTP helpers and it&#39;s the one everyone gets. You can use Fastify, Next.js or whatever you want here.</p>
<pre><code class="hljs language-bash"><button class="copy-btn">Copy</button>npm i express
</code></pre><pre><code class="hljs language-javascript"><button class="copy-btn">Copy</button><span class="hljs-keyword">import</span> express <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;express&quot;</span>;
<span class="hljs-keyword">import</span> { randomUUID } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;node:crypto&quot;</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">McpServer</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@modelcontextprotocol/sdk/server/mcp.js&quot;</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">StreamableHTTPServerTransport</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@modelcontextprotocol/sdk/server/streamableHttp.js&quot;</span>;
<span class="hljs-keyword">import</span> { isInitializeRequest } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@modelcontextprotocol/sdk/types.js&quot;</span>;
<span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;path&quot;</span>;
<span class="hljs-keyword">import</span> { fileURLToPath } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;url&quot;</span>;
<span class="hljs-keyword">import</span> jobsBasedTools <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./jobs-based-tools.js&quot;</span>;

<span class="hljs-keyword">const</span> __filename = <span class="hljs-title function_">fileURLToPath</span>(<span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">url</span>);
<span class="hljs-keyword">const</span> __dirname = path.<span class="hljs-title function_">dirname</span>(__filename);

<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();
app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">json</span>());

<span class="hljs-comment">// Map to store transports by session ID</span>
<span class="hljs-keyword">const</span> transports = {};

<span class="hljs-comment">// Function to create a new MCP server instance</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">createMcpServer</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> server = <span class="hljs-keyword">new</span> <span class="hljs-title class_">McpServer</span>({
    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;issues-tracker-server&quot;</span>,
    <span class="hljs-attr">version</span>: <span class="hljs-string">&quot;1.0.0&quot;</span>,
  });

  <span class="hljs-comment">// Register jobs-based tools</span>
  <span class="hljs-title function_">jobsBasedTools</span>(server);

  <span class="hljs-keyword">return</span> server;
}

<span class="hljs-comment">// Handle POST requests for client-to-server communication</span>
app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&quot;/mcp&quot;</span>, <span class="hljs-title function_">async</span> (req, res) =&gt; {
  <span class="hljs-comment">// Check for existing session ID</span>
  <span class="hljs-keyword">const</span> sessionId = req.<span class="hljs-property">headers</span>[<span class="hljs-string">&quot;mcp-session-id&quot;</span>];
  <span class="hljs-keyword">let</span> transport;

  <span class="hljs-keyword">if</span> (sessionId &amp;&amp; transports[sessionId]) {
    <span class="hljs-comment">// Reuse existing transport</span>
    transport = transports[sessionId];
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!sessionId &amp;&amp; <span class="hljs-title function_">isInitializeRequest</span>(req.<span class="hljs-property">body</span>)) {
    <span class="hljs-comment">// New initialization request</span>
    transport = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StreamableHTTPServerTransport</span>({
      <span class="hljs-attr">sessionIdGenerator</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">randomUUID</span>(),
      <span class="hljs-attr">onsessioninitialized</span>: <span class="hljs-function">(<span class="hljs-params">sessionId</span>) =&gt;</span> {
        <span class="hljs-comment">// Store the transport by session ID</span>
        transports[sessionId] = transport;
      },
      <span class="hljs-comment">// DNS rebinding protection is disabled for MCP Inspector compatibility</span>
      <span class="hljs-attr">enableDnsRebindingProtection</span>: <span class="hljs-literal">false</span>,
    });

    <span class="hljs-comment">// Clean up transport when closed</span>
    transport.<span class="hljs-property">onclose</span> = <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-keyword">if</span> (transport.<span class="hljs-property">sessionId</span>) {
        <span class="hljs-keyword">delete</span> transports[transport.<span class="hljs-property">sessionId</span>];
      }
    };

    <span class="hljs-keyword">const</span> server = <span class="hljs-title function_">createMcpServer</span>();

    <span class="hljs-comment">// Connect to the MCP server</span>
    <span class="hljs-keyword">await</span> server.<span class="hljs-title function_">connect</span>(transport);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// Invalid request</span>
    res.<span class="hljs-title function_">status</span>(<span class="hljs-number">400</span>).<span class="hljs-title function_">json</span>({
      <span class="hljs-attr">jsonrpc</span>: <span class="hljs-string">&quot;2.0&quot;</span>,
      <span class="hljs-attr">error</span>: {
        <span class="hljs-attr">code</span>: -<span class="hljs-number">32000</span>,
        <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;Bad Request: No valid session ID provided&quot;</span>,
      },
      <span class="hljs-attr">id</span>: <span class="hljs-literal">null</span>,
    });
    <span class="hljs-keyword">return</span>;
  }

  <span class="hljs-comment">// Handle the request</span>
  <span class="hljs-keyword">await</span> transport.<span class="hljs-title function_">handleRequest</span>(req, res, req.<span class="hljs-property">body</span>);
});

<span class="hljs-comment">// Reusable handler for GET and DELETE requests</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">handleSessionRequest</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">req, res</span>) =&gt; {
  <span class="hljs-keyword">const</span> sessionId = req.<span class="hljs-property">headers</span>[<span class="hljs-string">&quot;mcp-session-id&quot;</span>];
  <span class="hljs-keyword">if</span> (!sessionId || !transports[sessionId]) {
    res.<span class="hljs-title function_">status</span>(<span class="hljs-number">400</span>).<span class="hljs-title function_">send</span>(<span class="hljs-string">&quot;Invalid or missing session ID&quot;</span>);
    <span class="hljs-keyword">return</span>;
  }

  <span class="hljs-keyword">const</span> transport = transports[sessionId];
  <span class="hljs-keyword">await</span> transport.<span class="hljs-title function_">handleRequest</span>(req, res);
};

<span class="hljs-comment">// Handle GET requests for server-to-client notifications via SSE</span>
app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;/mcp&quot;</span>, handleSessionRequest);

<span class="hljs-comment">// Handle DELETE requests for session termination</span>
app.<span class="hljs-title function_">delete</span>(<span class="hljs-string">&quot;/mcp&quot;</span>, handleSessionRequest);

<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PORT</span> = <span class="hljs-number">3100</span>;
app.<span class="hljs-title function_">listen</span>(<span class="hljs-variable constant_">PORT</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`MCP Streamable HTTP Server listening on port <span class="hljs-subst">${PORT}</span>`</span>);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Server endpoint: http://localhost:<span class="hljs-subst">${PORT}</span>/mcp`</span>);
});
</code></pre><ul>
<li>Every sessions needs a UUID to keep track of which session is ongoing. I&#39;m just using node:crypto for this and JS object to keep track of it. This wouldn&#39;t scale - every client would need to hit the same client which makes it hard to scale. You&#39;d probaby use Redis or something to share state amongst stateless servers to scale this better.</li>
<li>We need to handle POST for client-to-server messages, GET for server-to-client messages, and DELETE for ending sessions.</li>
<li>I turned off the DNS rebinding protection so we can use the MCP inspector but this is something you&#39;d leave on in prod. Bascially you don&#39;t want people to be able to jack other people&#39;s sessions if they&#39;re able to guess the UUID, that would be a huge vulnerability. But locally it doesn&#39;t matter.</li>
<li>Beyond this, this should just look like a normal ol&#39; web server which it is. We definitely could have (and probably should have) just built this into our backend.</li>
</ul>
<p>Let&#39;s try in it now.</p>
<pre><code><button class="copy-btn">Copy</button>npx @modelcontextprotocol/inspector
</code></pre><p>Then in the UI put in <code>localhost:3100/mcp</code> to connect to your server. Make sure that you either click the link directly from the CLI or that you bring with you the session token. This is just so one or thing on your network can jack your local MCP session and do weird stuff. Again, it&#39;s a powerful tool so we need security to make sure it works okay!</p>
<p>Now you should see our three jobs-based tools in the inspector.</p>
<p>So what are limitations here?</p>
<ul>
<li>Obviously we can&#39;t just shell out CLI commands - we&#39;re constrained to only what we can do on our server and pass back to the user.</li>
<li>We have to worry a lot more about security - we don&#39;t want to leak other users&#39; data because we did something wrong.</li>
</ul>
<p>If you want more depth here, <a href="https://brightdata.com/blog/ai/sse-vs-streamable-http">I liked BrightData&#39;s blog post on it</a></p>
</div><div class="lesson-links"><a href="/lessons/sses-and-streaming-html/server-side-events" class="prev">← Previous</a><a href="/lessons/vibes/lets-vibe-code" class="next">Next →</a></div></div><div class="details-bg"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="154" height="154" viewBox="0 0 154 154"><defs><clipPath id="clip-path"><rect id="Rectangle_2238" data-name="Rectangle 2238" width="154" height="154" transform="translate(9467 350)" fill="#fff" stroke="#707070" stroke-width="1"></rect></clipPath><clipPath id="clip-corner-image-active"><rect width="154" height="154"></rect></clipPath></defs><g id="corner-image-active" clip-path="url(#clip-corner-image-active)"><g id="Corner-image-active-2" data-name="Corner-image-active" transform="translate(-9467 -350)" clip-path="url(#clip-path)"><path id="Subtraction_34" data-name="Subtraction 34" d="M-3857.365,1740.766h0l-7.07-7.07,12.89-12.89v14.142l-5.818,5.818Zm-14.142-14.142h0l-7.071-7.07,27.033-27.033v14.143l-19.96,19.96Zm-14.143-14.143h0l-7.07-7.069,41.175-41.175v14.142Zm-14.142-14.142h0l-7.07-7.069,55.317-55.317v14.142Zm-14.142-14.142h0l-7.07-7.069,69.459-69.459v14.142Zm-14.142-14.142h0l-7.07-7.069,76.739-76.739h6.862v7.28Zm-14.143-14.143h0l-7.07-7.069,62.6-62.6h14.142Zm-14.142-14.142h0l-7.07-7.069,48.454-48.454h14.142Zm-14.142-14.142h0l-7.07-7.069,34.312-34.312h14.142Zm-14.142-14.142h0l-7.07-7.069,20.17-20.17h14.142Zm-14.142-14.142h0l-7.071-7.071,6.027-6.027h14.144l-13.1,13.1Zm367.24-56.114v-.909l.455.455-.453.453Z" transform="translate(13472.546 -1236.766)" fill="var(--corner-fill)"></path></g></g></svg></div></div></div></div><noscript><img src="https://a.holt.courses/noscript.gif" alt="" referrerPolicy="no-referrer-when-downgrade"/></noscript><footer class="footer"><ul class="socials"><li class="social"><a href="https://twitter.com/holtbt"><svg fill="none" height="100%" width="32" xmlns="http://www.w3.org/2000/svg" viewBox="0.254 0.25 500 451.95400000000006"><path d="M394.033.25h76.67L303.202 191.693l197.052 260.511h-154.29L225.118 294.205 86.844 452.204H10.127l179.16-204.77L.254.25H158.46l109.234 144.417zm-26.908 406.063h42.483L135.377 43.73h-45.59z" fill="var(--footer-icons)"></path></svg></a></li><li class="social"><a href="https://bsky.app/profile/brianholt.me"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 -3.268 64 68.414" width="38" height="100%"><path fill="var(--footer-icons)" d="M13.873 3.805C21.21 9.332 29.103 20.537 32 26.55v15.882c0-.338-.13.044-.41.867-1.512 4.456-7.418 21.847-20.923 7.944-7.111-7.32-3.819-14.64 9.125-16.85-7.405 1.264-15.73-.825-18.014-9.015C1.12 23.022 0 8.51 0 6.55 0-3.268 8.579-.182 13.873 3.805zm36.254 0C42.79 9.332 34.897 20.537 32 26.55v15.882c0-.338.13.044.41.867 1.512 4.456 7.418 21.847 20.923 7.944 7.111-7.32 3.819-14.64-9.125-16.85 7.405 1.264 15.73-.825 18.014-9.015C62.88 23.022 64 8.51 64 6.55c0-9.818-8.578-6.732-13.873-2.745z"></path></svg></a></li><li class="social"><a href="https://github.com/btholt"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="32" height="32" viewBox="0 0 32 32"><defs><clipPath id="clip-github-social"><rect width="32" height="32"></rect></clipPath></defs><g id="github-social" clip-path="url(#clip-github-social)"><g id="Group_272" data-name="Group 272" transform="translate(13522.5 -6994)"><path id="Subtraction_33" data-name="Subtraction 33" d="M-24967.5,8041a15.9,15.9,0,0,1-11.312-4.688A15.893,15.893,0,0,1-24983.5,8025a15.893,15.893,0,0,1,4.689-11.315A15.894,15.894,0,0,1-24967.5,8009a15.894,15.894,0,0,1,11.313,4.686A15.893,15.893,0,0,1-24951.5,8025a15.893,15.893,0,0,1-4.689,11.313A15.9,15.9,0,0,1-24967.5,8041Zm-3.781-4.571h0v3.918h7.895v-6.665a1.836,1.836,0,0,0-1.2-1.718c5.1-.617,7.467-2.975,7.467-7.424a7.176,7.176,0,0,0-1.637-4.728,6.74,6.74,0,0,0,.275-1.812,4.34,4.34,0,0,0-.52-2.452.574.574,0,0,0-.359-.1c-1.061,0-3.465,1.411-3.936,1.694a16.644,16.644,0,0,0-4.2-.489,16.379,16.379,0,0,0-3.969.445c-.846-.5-2.91-1.649-3.859-1.649a.566.566,0,0,0-.354.095,4.3,4.3,0,0,0-.521,2.452,6.7,6.7,0,0,0,.244,1.718,7.346,7.346,0,0,0-1.6,4.822,7.263,7.263,0,0,0,1.533,4.985c1.193,1.359,3.115,2.165,5.871,2.464a1.826,1.826,0,0,0-1.129,1.693v.5h0l-.006,0a7.121,7.121,0,0,1-2.033.363,2.608,2.608,0,0,1-.965-.158,4.438,4.438,0,0,1-1.836-1.881,2.361,2.361,0,0,0-1.248-1.091,3.472,3.472,0,0,0-1.217-.3.584.584,0,0,0-.545.224.282.282,0,0,0,.027.367,1.875,1.875,0,0,0,.447.307,4.732,4.732,0,0,1,.561.355,10.726,10.726,0,0,1,1.682,2.755c.043.092.078.163.105.217a3.876,3.876,0,0,0,2.42,1.185,6.036,6.036,0,0,0,.607.025c.875,0,1.988-.124,2-.125Z" transform="translate(11461 -1015)" fill="var(--footer-icons)"></path><g id="Ellipse_670" data-name="Ellipse 670" transform="translate(-13522.5 6994)" fill="none" stroke="var(--footer-icons)" stroke-width="1"><circle cx="16" cy="16" r="16" stroke="none"></circle><circle cx="16" cy="16" r="15.5" fill="none"></circle></g></g></g></svg></a></li><li class="social"><a href="https://linkedin.com/in/btholt"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="32" height="32" viewBox="0 0 32 32"><defs><clipPath id="clip-linkedin-social"><rect width="32" height="32"></rect></clipPath></defs><g id="linkedin-social" clip-path="url(#clip-linkedin-social)"><g id="Group_270" data-name="Group 270" transform="translate(-86.349 -633.073)"><path id="Path_375" data-name="Path 375" d="M115.789,633.073a2.324,2.324,0,0,1,1.682.676,2.194,2.194,0,0,1,.695,1.627V662.8a2.131,2.131,0,0,1-.695,1.609,2.314,2.314,0,0,1-1.646.659H88.69a2.307,2.307,0,0,1-1.646-.659,2.128,2.128,0,0,1-.695-1.609V635.376a2.19,2.19,0,0,1,.695-1.627,2.322,2.322,0,0,1,1.682-.676h27.063Zm-20.224,9.672a2.561,2.561,0,0,0,0-3.584,2.658,2.658,0,0,0-1.938-.712,2.724,2.724,0,0,0-1.957.712,2.371,2.371,0,0,0-.75,1.792,2.4,2.4,0,0,0,.731,1.792,2.605,2.605,0,0,0,1.9.713h.037A2.7,2.7,0,0,0,95.565,642.745ZM96,645.434H91.213V659.88H96Zm17.3,6.144a7.007,7.007,0,0,0-1.573-4.9,5.68,5.68,0,0,0-6.839-.769,5.663,5.663,0,0,0-1.426,1.573v-2.048H98.674q.036.841,0,7.717v6.728h4.791V651.8a3.592,3.592,0,0,1,.146-1.17,2.913,2.913,0,0,1,.878-1.206,2.429,2.429,0,0,1,1.609-.549,2.108,2.108,0,0,1,1.865.914,4.265,4.265,0,0,1,.549,2.341v7.752H113.3Z" fill="var(--footer-icons)"></path></g></g></svg></a></li><li class="social"><div class="terms"><p>Content Licensed Under CC-BY-NC-4.0</p><p>Code Samples and Exercises Licensed Under Apache 2.0</p><p>Site Designed by<!-- --> <a href="https://www.alexdanielson.com/">Alex Danielson</a></p></div></li></ul><div class="theme-icons"><button aria-label="Activate dark mode" title="Activate dark mode" class="theme-toggle"><svg xmlns="http://www.w3.org/2000/svg" width="36px" height="100%" viewBox="0 -960 960 960" fill="var(--text-footer)" role="img"><title>Dark Mode Icon</title><path d="M480-120q-150 0-255-105T120-480q0-150 105-255t255-105q14 0 27.5 1t26.5 3q-41 29-65.5 75.5T444-660q0 90 63 153t153 63q55 0 101-24.5t75-65.5q2 13 3 26.5t1 27.5q0 150-105 255T480-120Zm0-80q88 0 158-48.5T740-375q-20 5-40 8t-40 3q-123 0-209.5-86.5T364-660q0-20 3-40t8-40q-78 32-126.5 102T200-480q0 116 82 198t198 82Z"></path></svg></button></div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"attributes":{"title":"Streamable HTTP","description":"Brian Holt walks you through building a Streamable HTTP MCP server in Node.js with Express, using a single /mcp endpoint and UUID-based sessions for client-server communication. The guide contrasts streamable HTTP with SSEs, demonstrates a concrete MCP setup (POST for client messages, GET for server messages, DELETE to end sessions), and covers scalability and security considerations plus inspector usage.","keywords":["MCP","Model Context Protocol","Streamable HTTP","Node.js","Express","session management"]},"html":"\u003cp\u003eMark my words, there is about to be a Cambrian explosion of MCP server frameworks for Node.js that will handle a lot of this plumbing for you. But there isn\u0026#39;t yet so we\u0026#39;re going to have to do some manual housekeeping of session data. We\u0026#39;re also not going to implement this in the most scalable way, but I\u0026#39;ll leave that as an exercise to you to do.\u003c/p\u003e\n\u003cp\u003eSo let\u0026#39;s talk about how streamable HTTP is different than SSEs. For one, there\u0026#39;s just the one endpoint - you don\u0026#39;t have to GET to one and POST to the other.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/streamable.png\" alt=\"Streamable HTTP diagram\"\u003e\u003c/p\u003e\n\u003cp\u003eThe topography of handshakes here is a bit more complicated but at the end you get a resumable session, one endpoint to deal with instead of two, and a server that can be stateless as long you architect it well.\u003c/p\u003e\n\u003cp\u003eBut yeah, the key here is that the server gives the session a UUID as a session ID and then the client refers to that using an HTTP header to make sure that the server and client both understand the ongoing context. That\u0026#39;s really it. The idea of SSEs still happen inside of this, but it\u0026#39;s only part of the architecture instead of all of it.\u003c/p\u003e\n\u003cp\u003eWe\u0026#39;re going to implement our MCP main.js again but instead in \u003ccode\u003estreamable.js\u003c/code\u003e and using Express as our Node.js server. Express is chosen because we really just need minimal HTTP helpers and it\u0026#39;s the one everyone gets. You can use Fastify, Next.js or whatever you want here.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003e\u003cbutton class=\"copy-btn\"\u003eCopy\u003c/button\u003enpm i express\n\u003c/code\u003e\u003c/pre\u003e\u003cpre\u003e\u003ccode class=\"hljs language-javascript\"\u003e\u003cbutton class=\"copy-btn\"\u003eCopy\u003c/button\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e express \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026quot;express\u0026quot;\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { randomUUID } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026quot;node:crypto\u0026quot;\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eMcpServer\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026quot;@modelcontextprotocol/sdk/server/mcp.js\u0026quot;\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eStreamableHTTPServerTransport\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026quot;@modelcontextprotocol/sdk/server/streamableHttp.js\u0026quot;\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { isInitializeRequest } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026quot;@modelcontextprotocol/sdk/types.js\u0026quot;\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e path \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026quot;path\u0026quot;\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { fileURLToPath } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026quot;url\u0026quot;\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e jobsBasedTools \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026quot;./jobs-based-tools.js\u0026quot;\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e __filename = \u003cspan class=\"hljs-title function_\"\u003efileURLToPath\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003emeta\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eurl\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e __dirname = path.\u003cspan class=\"hljs-title function_\"\u003edirname\u003c/span\u003e(__filename);\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e app = \u003cspan class=\"hljs-title function_\"\u003eexpress\u003c/span\u003e();\napp.\u003cspan class=\"hljs-title function_\"\u003euse\u003c/span\u003e(express.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e());\n\n\u003cspan class=\"hljs-comment\"\u003e// Map to store transports by session ID\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e transports = {};\n\n\u003cspan class=\"hljs-comment\"\u003e// Function to create a new MCP server instance\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecreateMcpServer\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e server = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMcpServer\u003c/span\u003e({\n    \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026quot;issues-tracker-server\u0026quot;\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003eversion\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026quot;1.0.0\u0026quot;\u003c/span\u003e,\n  });\n\n  \u003cspan class=\"hljs-comment\"\u003e// Register jobs-based tools\u003c/span\u003e\n  \u003cspan class=\"hljs-title function_\"\u003ejobsBasedTools\u003c/span\u003e(server);\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e server;\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// Handle POST requests for client-to-server communication\u003c/span\u003e\napp.\u003cspan class=\"hljs-title function_\"\u003epost\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026quot;/mcp\u0026quot;\u003c/span\u003e, \u003cspan class=\"hljs-title function_\"\u003easync\u003c/span\u003e (req, res) =\u0026gt; {\n  \u003cspan class=\"hljs-comment\"\u003e// Check for existing session ID\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e sessionId = req.\u003cspan class=\"hljs-property\"\u003eheaders\u003c/span\u003e[\u003cspan class=\"hljs-string\"\u003e\u0026quot;mcp-session-id\u0026quot;\u003c/span\u003e];\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e transport;\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (sessionId \u0026amp;\u0026amp; transports[sessionId]) {\n    \u003cspan class=\"hljs-comment\"\u003e// Reuse existing transport\u003c/span\u003e\n    transport = transports[sessionId];\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!sessionId \u0026amp;\u0026amp; \u003cspan class=\"hljs-title function_\"\u003eisInitializeRequest\u003c/span\u003e(req.\u003cspan class=\"hljs-property\"\u003ebody\u003c/span\u003e)) {\n    \u003cspan class=\"hljs-comment\"\u003e// New initialization request\u003c/span\u003e\n    transport = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eStreamableHTTPServerTransport\u003c/span\u003e({\n      \u003cspan class=\"hljs-attr\"\u003esessionIdGenerator\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e() =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erandomUUID\u003c/span\u003e(),\n      \u003cspan class=\"hljs-attr\"\u003eonsessioninitialized\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003esessionId\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n        \u003cspan class=\"hljs-comment\"\u003e// Store the transport by session ID\u003c/span\u003e\n        transports[sessionId] = transport;\n      },\n      \u003cspan class=\"hljs-comment\"\u003e// DNS rebinding protection is disabled for MCP Inspector compatibility\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003eenableDnsRebindingProtection\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e,\n    });\n\n    \u003cspan class=\"hljs-comment\"\u003e// Clean up transport when closed\u003c/span\u003e\n    transport.\u003cspan class=\"hljs-property\"\u003eonclose\u003c/span\u003e = \u003cspan class=\"hljs-function\"\u003e() =\u0026gt;\u003c/span\u003e {\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (transport.\u003cspan class=\"hljs-property\"\u003esessionId\u003c/span\u003e) {\n        \u003cspan class=\"hljs-keyword\"\u003edelete\u003c/span\u003e transports[transport.\u003cspan class=\"hljs-property\"\u003esessionId\u003c/span\u003e];\n      }\n    };\n\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e server = \u003cspan class=\"hljs-title function_\"\u003ecreateMcpServer\u003c/span\u003e();\n\n    \u003cspan class=\"hljs-comment\"\u003e// Connect to the MCP server\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e server.\u003cspan class=\"hljs-title function_\"\u003econnect\u003c/span\u003e(transport);\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// Invalid request\u003c/span\u003e\n    res.\u003cspan class=\"hljs-title function_\"\u003estatus\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e400\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e({\n      \u003cspan class=\"hljs-attr\"\u003ejsonrpc\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026quot;2.0\u0026quot;\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003eerror\u003c/span\u003e: {\n        \u003cspan class=\"hljs-attr\"\u003ecode\u003c/span\u003e: -\u003cspan class=\"hljs-number\"\u003e32000\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003emessage\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026quot;Bad Request: No valid session ID provided\u0026quot;\u003c/span\u003e,\n      },\n      \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e,\n    });\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e;\n  }\n\n  \u003cspan class=\"hljs-comment\"\u003e// Handle the request\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e transport.\u003cspan class=\"hljs-title function_\"\u003ehandleRequest\u003c/span\u003e(req, res, req.\u003cspan class=\"hljs-property\"\u003ebody\u003c/span\u003e);\n});\n\n\u003cspan class=\"hljs-comment\"\u003e// Reusable handler for GET and DELETE requests\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ehandleSessionRequest\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003ereq, res\u003c/span\u003e) =\u0026gt; {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e sessionId = req.\u003cspan class=\"hljs-property\"\u003eheaders\u003c/span\u003e[\u003cspan class=\"hljs-string\"\u003e\u0026quot;mcp-session-id\u0026quot;\u003c/span\u003e];\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!sessionId || !transports[sessionId]) {\n    res.\u003cspan class=\"hljs-title function_\"\u003estatus\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e400\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003esend\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026quot;Invalid or missing session ID\u0026quot;\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e;\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e transport = transports[sessionId];\n  \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e transport.\u003cspan class=\"hljs-title function_\"\u003ehandleRequest\u003c/span\u003e(req, res);\n};\n\n\u003cspan class=\"hljs-comment\"\u003e// Handle GET requests for server-to-client notifications via SSE\u003c/span\u003e\napp.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026quot;/mcp\u0026quot;\u003c/span\u003e, handleSessionRequest);\n\n\u003cspan class=\"hljs-comment\"\u003e// Handle DELETE requests for session termination\u003c/span\u003e\napp.\u003cspan class=\"hljs-title function_\"\u003edelete\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026quot;/mcp\u0026quot;\u003c/span\u003e, handleSessionRequest);\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003ePORT\u003c/span\u003e = \u003cspan class=\"hljs-number\"\u003e3100\u003c/span\u003e;\napp.\u003cspan class=\"hljs-title function_\"\u003elisten\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003ePORT\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e() =\u0026gt;\u003c/span\u003e {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`MCP Streamable HTTP Server listening on port \u003cspan class=\"hljs-subst\"\u003e${PORT}\u003c/span\u003e`\u003c/span\u003e);\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`Server endpoint: http://localhost:\u003cspan class=\"hljs-subst\"\u003e${PORT}\u003c/span\u003e/mcp`\u003c/span\u003e);\n});\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eEvery sessions needs a UUID to keep track of which session is ongoing. I\u0026#39;m just using node:crypto for this and JS object to keep track of it. This wouldn\u0026#39;t scale - every client would need to hit the same client which makes it hard to scale. You\u0026#39;d probaby use Redis or something to share state amongst stateless servers to scale this better.\u003c/li\u003e\n\u003cli\u003eWe need to handle POST for client-to-server messages, GET for server-to-client messages, and DELETE for ending sessions.\u003c/li\u003e\n\u003cli\u003eI turned off the DNS rebinding protection so we can use the MCP inspector but this is something you\u0026#39;d leave on in prod. Bascially you don\u0026#39;t want people to be able to jack other people\u0026#39;s sessions if they\u0026#39;re able to guess the UUID, that would be a huge vulnerability. But locally it doesn\u0026#39;t matter.\u003c/li\u003e\n\u003cli\u003eBeyond this, this should just look like a normal ol\u0026#39; web server which it is. We definitely could have (and probably should have) just built this into our backend.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eLet\u0026#39;s try in it now.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cbutton class=\"copy-btn\"\u003eCopy\u003c/button\u003enpx @modelcontextprotocol/inspector\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThen in the UI put in \u003ccode\u003elocalhost:3100/mcp\u003c/code\u003e to connect to your server. Make sure that you either click the link directly from the CLI or that you bring with you the session token. This is just so one or thing on your network can jack your local MCP session and do weird stuff. Again, it\u0026#39;s a powerful tool so we need security to make sure it works okay!\u003c/p\u003e\n\u003cp\u003eNow you should see our three jobs-based tools in the inspector.\u003c/p\u003e\n\u003cp\u003eSo what are limitations here?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eObviously we can\u0026#39;t just shell out CLI commands - we\u0026#39;re constrained to only what we can do on our server and pass back to the user.\u003c/li\u003e\n\u003cli\u003eWe have to worry a lot more about security - we don\u0026#39;t want to leak other users\u0026#39; data because we did something wrong.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIf you want more depth here, \u003ca href=\"https://brightdata.com/blog/ai/sse-vs-streamable-http\"\u003eI liked BrightData\u0026#39;s blog post on it\u003c/a\u003e\u003c/p\u003e\n","markdown":"\nMark my words, there is about to be a Cambrian explosion of MCP server frameworks for Node.js that will handle a lot of this plumbing for you. But there isn't yet so we're going to have to do some manual housekeeping of session data. We're also not going to implement this in the most scalable way, but I'll leave that as an exercise to you to do.\n\nSo let's talk about how streamable HTTP is different than SSEs. For one, there's just the one endpoint - you don't have to GET to one and POST to the other.\n\n![Streamable HTTP diagram](/images/streamable.png)\n\nThe topography of handshakes here is a bit more complicated but at the end you get a resumable session, one endpoint to deal with instead of two, and a server that can be stateless as long you architect it well.\n\nBut yeah, the key here is that the server gives the session a UUID as a session ID and then the client refers to that using an HTTP header to make sure that the server and client both understand the ongoing context. That's really it. The idea of SSEs still happen inside of this, but it's only part of the architecture instead of all of it.\n\nWe're going to implement our MCP main.js again but instead in `streamable.js` and using Express as our Node.js server. Express is chosen because we really just need minimal HTTP helpers and it's the one everyone gets. You can use Fastify, Next.js or whatever you want here.\n\n```bash\nnpm i express\n```\n\n```javascript\nimport express from \"express\";\nimport { randomUUID } from \"node:crypto\";\nimport { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport { StreamableHTTPServerTransport } from \"@modelcontextprotocol/sdk/server/streamableHttp.js\";\nimport { isInitializeRequest } from \"@modelcontextprotocol/sdk/types.js\";\nimport path from \"path\";\nimport { fileURLToPath } from \"url\";\nimport jobsBasedTools from \"./jobs-based-tools.js\";\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\nconst app = express();\napp.use(express.json());\n\n// Map to store transports by session ID\nconst transports = {};\n\n// Function to create a new MCP server instance\nfunction createMcpServer() {\n  const server = new McpServer({\n    name: \"issues-tracker-server\",\n    version: \"1.0.0\",\n  });\n\n  // Register jobs-based tools\n  jobsBasedTools(server);\n\n  return server;\n}\n\n// Handle POST requests for client-to-server communication\napp.post(\"/mcp\", async (req, res) =\u003e {\n  // Check for existing session ID\n  const sessionId = req.headers[\"mcp-session-id\"];\n  let transport;\n\n  if (sessionId \u0026\u0026 transports[sessionId]) {\n    // Reuse existing transport\n    transport = transports[sessionId];\n  } else if (!sessionId \u0026\u0026 isInitializeRequest(req.body)) {\n    // New initialization request\n    transport = new StreamableHTTPServerTransport({\n      sessionIdGenerator: () =\u003e randomUUID(),\n      onsessioninitialized: (sessionId) =\u003e {\n        // Store the transport by session ID\n        transports[sessionId] = transport;\n      },\n      // DNS rebinding protection is disabled for MCP Inspector compatibility\n      enableDnsRebindingProtection: false,\n    });\n\n    // Clean up transport when closed\n    transport.onclose = () =\u003e {\n      if (transport.sessionId) {\n        delete transports[transport.sessionId];\n      }\n    };\n\n    const server = createMcpServer();\n\n    // Connect to the MCP server\n    await server.connect(transport);\n  } else {\n    // Invalid request\n    res.status(400).json({\n      jsonrpc: \"2.0\",\n      error: {\n        code: -32000,\n        message: \"Bad Request: No valid session ID provided\",\n      },\n      id: null,\n    });\n    return;\n  }\n\n  // Handle the request\n  await transport.handleRequest(req, res, req.body);\n});\n\n// Reusable handler for GET and DELETE requests\nconst handleSessionRequest = async (req, res) =\u003e {\n  const sessionId = req.headers[\"mcp-session-id\"];\n  if (!sessionId || !transports[sessionId]) {\n    res.status(400).send(\"Invalid or missing session ID\");\n    return;\n  }\n\n  const transport = transports[sessionId];\n  await transport.handleRequest(req, res);\n};\n\n// Handle GET requests for server-to-client notifications via SSE\napp.get(\"/mcp\", handleSessionRequest);\n\n// Handle DELETE requests for session termination\napp.delete(\"/mcp\", handleSessionRequest);\n\nconst PORT = 3100;\napp.listen(PORT, () =\u003e {\n  console.log(`MCP Streamable HTTP Server listening on port ${PORT}`);\n  console.log(`Server endpoint: http://localhost:${PORT}/mcp`);\n});\n```\n\n- Every sessions needs a UUID to keep track of which session is ongoing. I'm just using node:crypto for this and JS object to keep track of it. This wouldn't scale - every client would need to hit the same client which makes it hard to scale. You'd probaby use Redis or something to share state amongst stateless servers to scale this better.\n- We need to handle POST for client-to-server messages, GET for server-to-client messages, and DELETE for ending sessions.\n- I turned off the DNS rebinding protection so we can use the MCP inspector but this is something you'd leave on in prod. Bascially you don't want people to be able to jack other people's sessions if they're able to guess the UUID, that would be a huge vulnerability. But locally it doesn't matter.\n- Beyond this, this should just look like a normal ol' web server which it is. We definitely could have (and probably should have) just built this into our backend.\n\nLet's try in it now.\n\n```\nnpx @modelcontextprotocol/inspector\n```\n\nThen in the UI put in `localhost:3100/mcp` to connect to your server. Make sure that you either click the link directly from the CLI or that you bring with you the session token. This is just so one or thing on your network can jack your local MCP session and do weird stuff. Again, it's a powerful tool so we need security to make sure it works okay!\n\nNow you should see our three jobs-based tools in the inspector.\n\nSo what are limitations here?\n\n- Obviously we can't just shell out CLI commands - we're constrained to only what we can do on our server and pass back to the user.\n- We have to worry a lot more about security - we don't want to leak other users' data because we did something wrong.\n\nIf you want more depth here, [I liked BrightData's blog post on it][brightdata]\n\n[brightdata]: https://brightdata.com/blog/ai/sse-vs-streamable-http\n","slug":"streamable-http","title":"Streamable HTTP","section":"SSEs and Streaming HTML","icon":"bars-staggered","filePath":"/home/runner/work/complete-intro-to-mcp/complete-intro-to-mcp/lessons/06-sses-and-streaming-html/B-streamable-http.md","nextSlug":"/lessons/vibes/lets-vibe-code","prevSlug":"/lessons/sses-and-streaming-html/server-side-events"}},"__N_SSG":true},"page":"/lessons/[section]/[slug]","query":{"section":"sses-and-streaming-html","slug":"streamable-http"},"buildId":"3Mg5_eXgxRUcnLOJp0h8Y","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>