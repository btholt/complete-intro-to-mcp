{"pageProps":{"post":{"attributes":{"title":"MCP Server Design","description":"Brian Holt guides you through building a real MCP server for an issue tracker, including step-by-step setup (clone the app, install dependencies, create an MCP directory, and run the server) and a sample main.js that registers a database-schema resource. The tutorial emphasizes using MCP to orchestrate end-to-end tasks with Claude Desktop for conversational ticketing—addressing auth, operation order, and consistent tagging—so you can create tickets, assign users, and apply correct labels via AI.","keywords":["MCP server","Model Context Protocol","issue tracker","Claude Desktop","AI tools","Brian Holt"]},"html":"<p>We are going to do a real project now: an MCP server for an <a href=\"https://github.com/btholt/mcp-issue-tracker\">issue tracker</a>!</p>\n<blockquote>\n<p>Generally I avoid mass-use of AI in my courses but I feel it worthwhile to disclose that I &quot;vibe&quot; coded this app. It felt like it fit within the theme of the course and I wanted a fairly robust app with a frontend so you could see the changes happening in real time. There also may be AI generated bugs too! Feel free to code or &quot;vibe&quot; some PRs to fix them!</p>\n</blockquote>\n<h2>Setup the Issue Tracker App</h2>\n<p>Note: You only need to do these steps if you didn&#39;t complete the Resources lesson earlier in the course.</p>\n<ol>\n<li>Git clone the app locally</li>\n<li>Run <code>npm install</code> in the root, frontend, and backend directories:</li>\n</ol>\n<pre><code class=\"hljs language-bash\"><button class=\"copy-btn\">Copy</button>git <span class=\"hljs-built_in\">clone</span> https://github.com/btholt/mcp-issue-tracker.git\n<span class=\"hljs-built_in\">cd</span> mcp-issue-tracker &amp;&amp; npm i <span class=\"hljs-comment\"># install dependencies in root directory</span>\n<span class=\"hljs-built_in\">cd</span> frontend &amp;&amp; npm i <span class=\"hljs-comment\"># install dependencies in frontend directory</span>\n<span class=\"hljs-built_in\">cd</span> ../backend &amp;&amp; npm i <span class=\"hljs-comment\"># install dependencies in backend directory</span>\n<span class=\"hljs-built_in\">cd</span> ../\nnpm run dev <span class=\"hljs-comment\"># run dev script in root directory to start both frontend and backend servers</span>\n<span class=\"hljs-comment\"># open http://localhost:5173</span>\n</code></pre><ol>\n<li>Feel free to run <code>npm run dev</code> from the root directory to get both backend and frontend running and check it out at <a href=\"\">http://localhost:5173</a></li>\n<li>Create a <code>my-mcp</code> directory in the root directory (the <code>mcp</code> directory is the solution)</li>\n<li>In the mcp directory run <code>npm init -y</code></li>\n<li>Then run <code>npm i @modelcontextprotocol/sdk@1.16.0 zod@3.25.76</code></li>\n<li>Add <code>&quot;type&quot;: &quot;module&quot;</code> to the package.json</li>\n<li>Finally, create a file called called main.js and put this in there.</li>\n</ol>\n<pre><code class=\"hljs language-javascript\"><button class=\"copy-btn\">Copy</button><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">McpServer</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@modelcontextprotocol/sdk/server/mcp.js&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">StdioServerTransport</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@modelcontextprotocol/sdk/server/stdio.js&quot;</span>;\n<span class=\"hljs-keyword\">import</span> sqlite3 <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;sqlite3&quot;</span>;\n<span class=\"hljs-keyword\">import</span> path <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;path&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { fileURLToPath } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;url&quot;</span>;\n\n<span class=\"hljs-keyword\">const</span> __filename = <span class=\"hljs-title function_\">fileURLToPath</span>(<span class=\"hljs-keyword\">import</span>.<span class=\"hljs-property\">meta</span>.<span class=\"hljs-property\">url</span>);\n<span class=\"hljs-keyword\">const</span> __dirname = path.<span class=\"hljs-title function_\">dirname</span>(__filename);\n\n<span class=\"hljs-comment\">// Create an MCP server</span>\n<span class=\"hljs-keyword\">const</span> server = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">McpServer</span>({\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;issues-server&quot;</span>,\n  <span class=\"hljs-attr\">version</span>: <span class=\"hljs-string\">&quot;1.0.0&quot;</span>,\n});\n\n<span class=\"hljs-comment\">// Register the database schema resource</span>\nserver.<span class=\"hljs-title function_\">registerResource</span>(\n  <span class=\"hljs-string\">&quot;database-schema&quot;</span>,\n  <span class=\"hljs-string\">&quot;schema://database&quot;</span>,\n  {\n    <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">&quot;Database Schema&quot;</span>,\n    <span class=\"hljs-attr\">description</span>: <span class=\"hljs-string\">&quot;SQLite schema for the issues database&quot;</span>,\n    <span class=\"hljs-attr\">mimeType</span>: <span class=\"hljs-string\">&quot;text/plain&quot;</span>,\n  },\n  <span class=\"hljs-title function_\">async</span> (uri) =&gt; {\n    <span class=\"hljs-keyword\">const</span> dbPath = path.<span class=\"hljs-title function_\">join</span>(__dirname, <span class=\"hljs-string\">&quot;..&quot;</span>, <span class=\"hljs-string\">&quot;backend&quot;</span>, <span class=\"hljs-string\">&quot;database.sqlite&quot;</span>);\n\n    <span class=\"hljs-keyword\">const</span> schema = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> {\n      <span class=\"hljs-keyword\">const</span> db = <span class=\"hljs-keyword\">new</span> sqlite3.<span class=\"hljs-title class_\">Database</span>(dbPath, sqlite3.<span class=\"hljs-property\">OPEN_READONLY</span>);\n\n      db.<span class=\"hljs-title function_\">all</span>(\n        <span class=\"hljs-string\">&quot;SELECT sql FROM sqlite_master WHERE type=&#x27;table&#x27; AND sql IS NOT NULL ORDER BY name&quot;</span>,\n        <span class=\"hljs-function\">(<span class=\"hljs-params\">err, rows</span>) =&gt;</span> {\n          db.<span class=\"hljs-title function_\">close</span>();\n          <span class=\"hljs-keyword\">if</span> (err) <span class=\"hljs-title function_\">reject</span>(err);\n          <span class=\"hljs-keyword\">else</span> <span class=\"hljs-title function_\">resolve</span>(rows.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">row</span>) =&gt;</span> row.<span class=\"hljs-property\">sql</span> + <span class=\"hljs-string\">&quot;;&quot;</span>).<span class=\"hljs-title function_\">join</span>(<span class=\"hljs-string\">&quot;\\n&quot;</span>));\n        }\n      );\n    });\n\n    <span class=\"hljs-keyword\">return</span> {\n      <span class=\"hljs-attr\">contents</span>: [\n        {\n          <span class=\"hljs-attr\">uri</span>: uri.<span class=\"hljs-property\">href</span>,\n          <span class=\"hljs-attr\">mimeType</span>: <span class=\"hljs-string\">&quot;text/plain&quot;</span>,\n          <span class=\"hljs-attr\">text</span>: schema,\n        },\n      ],\n    };\n  }\n);\n\n<span class=\"hljs-comment\">// Start receiving messages on stdin and sending messages on stdout</span>\n<span class=\"hljs-keyword\">const</span> transport = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">StdioServerTransport</span>();\n<span class=\"hljs-keyword\">await</span> server.<span class=\"hljs-title function_\">connect</span>(transport);\n</code></pre><p>This will get you to a spot where we can start coding our MCP server for our issues app.</p>\n<h2>The App</h2>\n<p>The app is a very basic issue tracker where issues can be CRUD&#39;d. Issues have titles, IDs, assigned persons, tags, status, priority, and created by users.</p>\n<p>Ideally, we can connect our app to Claude Desktop via MCP server so that we can be working with Claude and say &quot;hey, this is a good thing to track. Create a high priority ticket and assign it to Jane Smith&quot; and the LLM can just handle the rest. I&#39;m sure you can see the value of being able to interact with your issue system conversationally and in context.</p>\n<p>So what all do we need to worry about?</p>\n<ul>\n<li>Auth. Claude needs to be able to act on behalf of us.</li>\n<li>Order of operations. We need an issue to an exist before we can update it.</li>\n<li>Correct tags/people/etc. to assign to issues. We don&#39;t want &quot;bug&quot;, &quot;bugs&quot;, &quot;issues&quot;, &quot;prod-issue&quot;, and a trillion variations. We want one &quot;bug&quot; tag.</li>\n</ul>\n<p>As you can see, there&#39;s a lot to juggle here, and it&#39;s trusting an LLM a lot to just say &quot;here Claude, use the API directly&quot;. Inevitably it&#39;s going to mess up a lot. Instead of just wrapping our API directly, we&#39;re going to make an MCP server that covers entire &quot;jobs to do&quot; instead of API steps. So we&#39;re going to make a tool that &quot;creates a ticket, assigns a user, and gives a correct label to it&quot; instead of just hoping that Claude can get the sequence of API calls right.</p>\n<p>Let&#39;s go give it a shot!</p>\n","markdown":"\nWe are going to do a real project now: an MCP server for an [issue tracker][issue]!\n\n> Generally I avoid mass-use of AI in my courses but I feel it worthwhile to disclose that I \"vibe\" coded this app. It felt like it fit within the theme of the course and I wanted a fairly robust app with a frontend so you could see the changes happening in real time. There also may be AI generated bugs too! Feel free to code or \"vibe\" some PRs to fix them!\n\n## Setup the Issue Tracker App\n\nNote: You only need to do these steps if you didn't complete the Resources lesson earlier in the course.\n\n1. Git clone the app locally\n1. Run `npm install` in the root, frontend, and backend directories:\n\n```bash\ngit clone https://github.com/btholt/mcp-issue-tracker.git\ncd mcp-issue-tracker && npm i # install dependencies in root directory\ncd frontend && npm i # install dependencies in frontend directory\ncd ../backend && npm i # install dependencies in backend directory\ncd ../\nnpm run dev # run dev script in root directory to start both frontend and backend servers\n# open http://localhost:5173\n```\n\n1. Feel free to run `npm run dev` from the root directory to get both backend and frontend running and check it out at [http://localhost:5173]()\n1. Create a `my-mcp` directory in the root directory (the `mcp` directory is the solution)\n1. In the mcp directory run `npm init -y`\n1. Then run `npm i @modelcontextprotocol/sdk@1.16.0 zod@3.25.76`\n1. Add `\"type\": \"module\"` to the package.json\n1. Finally, create a file called called main.js and put this in there.\n\n```javascript\nimport { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport sqlite3 from \"sqlite3\";\nimport path from \"path\";\nimport { fileURLToPath } from \"url\";\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\n// Create an MCP server\nconst server = new McpServer({\n  name: \"issues-server\",\n  version: \"1.0.0\",\n});\n\n// Register the database schema resource\nserver.registerResource(\n  \"database-schema\",\n  \"schema://database\",\n  {\n    title: \"Database Schema\",\n    description: \"SQLite schema for the issues database\",\n    mimeType: \"text/plain\",\n  },\n  async (uri) => {\n    const dbPath = path.join(__dirname, \"..\", \"backend\", \"database.sqlite\");\n\n    const schema = await new Promise((resolve, reject) => {\n      const db = new sqlite3.Database(dbPath, sqlite3.OPEN_READONLY);\n\n      db.all(\n        \"SELECT sql FROM sqlite_master WHERE type='table' AND sql IS NOT NULL ORDER BY name\",\n        (err, rows) => {\n          db.close();\n          if (err) reject(err);\n          else resolve(rows.map((row) => row.sql + \";\").join(\"\\n\"));\n        }\n      );\n    });\n\n    return {\n      contents: [\n        {\n          uri: uri.href,\n          mimeType: \"text/plain\",\n          text: schema,\n        },\n      ],\n    };\n  }\n);\n\n// Start receiving messages on stdin and sending messages on stdout\nconst transport = new StdioServerTransport();\nawait server.connect(transport);\n```\n\nThis will get you to a spot where we can start coding our MCP server for our issues app.\n\n## The App\n\nThe app is a very basic issue tracker where issues can be CRUD'd. Issues have titles, IDs, assigned persons, tags, status, priority, and created by users.\n\nIdeally, we can connect our app to Claude Desktop via MCP server so that we can be working with Claude and say \"hey, this is a good thing to track. Create a high priority ticket and assign it to Jane Smith\" and the LLM can just handle the rest. I'm sure you can see the value of being able to interact with your issue system conversationally and in context.\n\nSo what all do we need to worry about?\n\n- Auth. Claude needs to be able to act on behalf of us.\n- Order of operations. We need an issue to an exist before we can update it.\n- Correct tags/people/etc. to assign to issues. We don't want \"bug\", \"bugs\", \"issues\", \"prod-issue\", and a trillion variations. We want one \"bug\" tag.\n\nAs you can see, there's a lot to juggle here, and it's trusting an LLM a lot to just say \"here Claude, use the API directly\". Inevitably it's going to mess up a lot. Instead of just wrapping our API directly, we're going to make an MCP server that covers entire \"jobs to do\" instead of API steps. So we're going to make a tool that \"creates a ticket, assigns a user, and gives a correct label to it\" instead of just hoping that Claude can get the sequence of API calls right.\n\nLet's go give it a shot!\n\n[issue]: https://github.com/btholt/mcp-issue-tracker\n","slug":"mcp-server-design","title":"MCP Server Design","section":"Our Project","icon":"screwdriver-wrench","filePath":"/home/runner/work/complete-intro-to-mcp/complete-intro-to-mcp/lessons/05-our-project/A-mcp-server-design.md","nextSlug":"/lessons/our-project/api-based-tools","prevSlug":"/lessons/lets-build-mcp/future-features-of-mcp"}},"__N_SSG":true}