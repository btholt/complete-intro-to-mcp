{"pageProps":{"post":{"attributes":{"description":"Brian Holt's Complete Intro to MCP tutorial dives into the 'wrong way' of mapping each API call to an MCP tool within an issue-tracker app, then shows how to build reusable MCP tools like 'Create Issue' and 'List Tags' with clear input schemas and API-key handling. It includes practical code snippets, integration steps for Claude Desktop or other agents, and guidance on testing and scaling MCP workflows.","keywords":["MCP","Model Context Protocol","AI tools","Issue tracker","API key","Brian Holt","Frontend Masters"]},"html":"<p>So let&#39;s start with what I would call the wrong way of doing MCP â€“ a one-to-one mapping of an API call to an MCP tool. Our issue tracker has about 15ish API calls, we&#39;re going to make each one into a tool. We&#39;ll get into why this could be a bad call but for now, it&#39;s the simplest conceptually to grasp so let&#39;s go do that. Or rather, I&#39;m going to make you actually write the code for one and then let you copy/paste the rest. Feel free to do the whole thing, it&#39;s just a lot of code of doing the same thing.</p>\n<p>First, let&#39;s familiarize ourselves with the codebase in the Issues Tracker app. <a href=\"https://github.com/btholt/mcp-issue-tracker?tab=readme-ov-file#api-documentation\">The code is here on GitHub</a>, specifically the API documentation. Let&#39;s skip making the auth headers - it&#39;s too easy to prove my point. Getting an agent to successfully sign up and then manage a session just never worked for me, even when I was really trying to. So I made it so you can just nab a valid API key from the frontend. Sign up as a user and click &quot;copy API key&quot; from the header.</p>\n<blockquote>\n<p>ðŸš¨ In the name of simplicity, I made it so every user can only ever have one valid API key at a time. If you click &quot;copy API key&quot; again, it&#39;ll generate a new one and copy it to your clipboard, meaning if you were using that API key elsewhere, it&#39;s now invalid. I didn&#39;t want to make a whole key management system.</p>\n</blockquote>\n<p>So let&#39;s implement a tool to create issues.</p>\n<pre><code class=\"hljs language-javascript\"><button class=\"copy-btn\">Copy</button><span class=\"hljs-keyword\">import</span> { z } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;zod&quot;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">apiBasedTools</span>(<span class=\"hljs-params\">server</span>) {\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-variable constant_\">API_BASE_URL</span> = process.<span class=\"hljs-property\">env</span>.<span class=\"hljs-property\">API_BASE_URL</span> || <span class=\"hljs-string\">&quot;http://localhost:3000/api&quot;</span>;\n\n  <span class=\"hljs-comment\">// Helper function to make HTTP requests</span>\n  <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">makeRequest</span>(<span class=\"hljs-params\">method, url, data = <span class=\"hljs-literal\">null</span>, options = {}</span>) {\n    <span class=\"hljs-keyword\">const</span> config = {\n      method,\n      <span class=\"hljs-attr\">headers</span>: {\n        <span class=\"hljs-string\">&quot;Content-Type&quot;</span>: <span class=\"hljs-string\">&quot;application/json&quot;</span>,\n        ...options.<span class=\"hljs-property\">headers</span>,\n      },\n    };\n\n    <span class=\"hljs-comment\">// Merge other options except headers (which we already handled)</span>\n    <span class=\"hljs-keyword\">const</span> { <span class=\"hljs-attr\">headers</span>: _, ...otherOptions } = options;\n    <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(config, otherOptions);\n\n    <span class=\"hljs-keyword\">if</span> (data) {\n      config.<span class=\"hljs-property\">body</span> = <span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>(data);\n    }\n\n    <span class=\"hljs-keyword\">try</span> {\n      <span class=\"hljs-keyword\">const</span> response = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetch</span>(url, config);\n      <span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-keyword\">await</span> response.<span class=\"hljs-title function_\">text</span>();\n\n      <span class=\"hljs-keyword\">let</span> jsonResult;\n      <span class=\"hljs-keyword\">try</span> {\n        jsonResult = <span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">parse</span>(result);\n      } <span class=\"hljs-keyword\">catch</span> {\n        jsonResult = result;\n      }\n\n      <span class=\"hljs-keyword\">return</span> {\n        <span class=\"hljs-attr\">status</span>: response.<span class=\"hljs-property\">status</span>,\n        <span class=\"hljs-attr\">data</span>: jsonResult,\n        <span class=\"hljs-attr\">headers</span>: <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">fromEntries</span>(response.<span class=\"hljs-property\">headers</span>.<span class=\"hljs-title function_\">entries</span>()),\n      };\n    } <span class=\"hljs-keyword\">catch</span> (error) {\n      <span class=\"hljs-keyword\">return</span> {\n        <span class=\"hljs-attr\">status</span>: <span class=\"hljs-number\">0</span>,\n        <span class=\"hljs-attr\">error</span>: error.<span class=\"hljs-property\">message</span>,\n      };\n    }\n  }\n  server.<span class=\"hljs-title function_\">registerTool</span>(\n    <span class=\"hljs-string\">&quot;issues-create&quot;</span>,\n    {\n      <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">&quot;Create Issue&quot;</span>,\n      <span class=\"hljs-attr\">description</span>: <span class=\"hljs-string\">&quot;Create a new issue&quot;</span>,\n      <span class=\"hljs-attr\">inputSchema</span>: {\n        <span class=\"hljs-attr\">title</span>: z.<span class=\"hljs-title function_\">string</span>().<span class=\"hljs-title function_\">describe</span>(<span class=\"hljs-string\">&quot;Issue title&quot;</span>),\n        <span class=\"hljs-attr\">description</span>: z.<span class=\"hljs-title function_\">string</span>().<span class=\"hljs-title function_\">optional</span>().<span class=\"hljs-title function_\">describe</span>(<span class=\"hljs-string\">&quot;Issue description&quot;</span>),\n        <span class=\"hljs-attr\">status</span>: z\n          .<span class=\"hljs-title function_\">enum</span>([<span class=\"hljs-string\">&quot;not_started&quot;</span>, <span class=\"hljs-string\">&quot;in_progress&quot;</span>, <span class=\"hljs-string\">&quot;done&quot;</span>])\n          .<span class=\"hljs-title function_\">optional</span>()\n          .<span class=\"hljs-title function_\">describe</span>(<span class=\"hljs-string\">&quot;Issue status&quot;</span>),\n        <span class=\"hljs-attr\">priority</span>: z\n          .<span class=\"hljs-title function_\">enum</span>([<span class=\"hljs-string\">&quot;low&quot;</span>, <span class=\"hljs-string\">&quot;medium&quot;</span>, <span class=\"hljs-string\">&quot;high&quot;</span>, <span class=\"hljs-string\">&quot;urgent&quot;</span>])\n          .<span class=\"hljs-title function_\">optional</span>()\n          .<span class=\"hljs-title function_\">describe</span>(<span class=\"hljs-string\">&quot;Issue priority&quot;</span>),\n        <span class=\"hljs-attr\">assigned_user_id</span>: z.<span class=\"hljs-title function_\">string</span>().<span class=\"hljs-title function_\">optional</span>().<span class=\"hljs-title function_\">describe</span>(<span class=\"hljs-string\">&quot;Assigned user ID&quot;</span>),\n        <span class=\"hljs-attr\">tag_ids</span>: z.<span class=\"hljs-title function_\">array</span>(z.<span class=\"hljs-title function_\">number</span>()).<span class=\"hljs-title function_\">optional</span>().<span class=\"hljs-title function_\">describe</span>(<span class=\"hljs-string\">&quot;Array of tag IDs&quot;</span>),\n        <span class=\"hljs-attr\">apiKey</span>: z.<span class=\"hljs-title function_\">string</span>().<span class=\"hljs-title function_\">describe</span>(<span class=\"hljs-string\">&quot;API key for authentication&quot;</span>),\n      },\n    },\n    <span class=\"hljs-title function_\">async</span> (params) =&gt; {\n      <span class=\"hljs-keyword\">const</span> { apiKey, ...issueData } = params;\n\n      <span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">makeRequest</span>(\n        <span class=\"hljs-string\">&quot;POST&quot;</span>,\n        <span class=\"hljs-string\">`<span class=\"hljs-subst\">${API_BASE_URL}</span>/issues`</span>,\n        issueData,\n        { <span class=\"hljs-attr\">headers</span>: { <span class=\"hljs-string\">&quot;x-api-key&quot;</span>: apiKey } }\n      );\n\n      <span class=\"hljs-keyword\">return</span> {\n        <span class=\"hljs-attr\">content</span>: [\n          {\n            <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&quot;text&quot;</span>,\n            <span class=\"hljs-attr\">text</span>: <span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>(result, <span class=\"hljs-literal\">null</span>, <span class=\"hljs-number\">2</span>),\n          },\n        ],\n      };\n    }\n  );\n}\n</code></pre><p>Pretty straight forward. The zod types both make it very readable to use and it&#39;s what the LLM is going to use to decide what to put where. Let&#39;s add one more to list all tags.</p>\n<p>We made this into a function that we can then import into our main.js and use. So back there and add this</p>\n<pre><code class=\"hljs language-javascript\"><button class=\"copy-btn\">Copy</button><span class=\"hljs-comment\">// at top</span>\n<span class=\"hljs-keyword\">import</span> apiBasedTools <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./api-based-tools.js&quot;</span>;\n\n<span class=\"hljs-comment\">// under new McpServer</span>\n<span class=\"hljs-title function_\">apiBasedTools</span>(server);\n</code></pre><p>Make sure you&#39;ve added this MCP server to your Claude Desktop / Tome, restart it, and then try the prompt</p>\n<pre><code><button class=\"copy-btn\">Copy</button>Create a new issue in my issue tracker that says &quot;Add Google login to my app&quot;, mark it as in progress, and mark it as medium priority. Here is my API key: &lt;YOUR API KEY&gt;\n</code></pre><p>Okay, let&#39;s take it a step further. Let&#39;s say we want to be able to add tags to it. Right now if you say &quot;mark it as a bug&quot; it will try to put &quot;bug&quot; as the tag ID but the tag ID is a number. So the user either needs to know that &quot;bug&quot; is tag ID ## or it just won&#39;t work. Let&#39;s add a tool for that.</p>\n<p>Add this tool.</p>\n<pre><code class=\"hljs language-javascript\"><button class=\"copy-btn\">Copy</button>server.<span class=\"hljs-title function_\">registerTool</span>(\n  <span class=\"hljs-string\">&quot;tags-list&quot;</span>,\n  {\n    <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">&quot;List Tags&quot;</span>,\n    <span class=\"hljs-attr\">description</span>: <span class=\"hljs-string\">&quot;Get all available tags&quot;</span>,\n    <span class=\"hljs-attr\">inputSchema</span>: {\n      <span class=\"hljs-attr\">apiKey</span>: z.<span class=\"hljs-title function_\">string</span>().<span class=\"hljs-title function_\">describe</span>(<span class=\"hljs-string\">&quot;API key for authentication&quot;</span>),\n    },\n  },\n  <span class=\"hljs-title function_\">async</span> ({ apiKey }) =&gt; {\n    <span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">makeRequest</span>(<span class=\"hljs-string\">&quot;GET&quot;</span>, <span class=\"hljs-string\">`<span class=\"hljs-subst\">${API_BASE_URL}</span>/tags`</span>, <span class=\"hljs-literal\">null</span>, {\n      <span class=\"hljs-attr\">headers</span>: { <span class=\"hljs-string\">&quot;x-api-key&quot;</span>: apiKey },\n    });\n\n    <span class=\"hljs-keyword\">return</span> {\n      <span class=\"hljs-attr\">content</span>: [\n        {\n          <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&quot;text&quot;</span>,\n          <span class=\"hljs-attr\">text</span>: <span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>(result, <span class=\"hljs-literal\">null</span>, <span class=\"hljs-number\">2</span>),\n        },\n      ],\n    };\n  }\n);\n</code></pre><p>Now try</p>\n<pre><code><button class=\"copy-btn\">Copy</button>Create a new issue in my issue tracker that says &quot;Add Microsoft login to my app&quot;, mark it as not started, and mark it as urgent priority. Add the tags frontend and feature. Here is my API key: &lt;YOUR API KEY&gt;\n</code></pre><p>Now, if you&#39;re using Claude Desktop, this will probably work. If you&#39;re using Qwen3:0.6B, well, flip a coin. I&#39;ve had a hard time to get the smallest Qwen 3 model to do anything more than one step.</p>\n<p>Once you feel okay with that, go ahead and change the import in main.js to import from the complete file</p>\n<pre><code class=\"hljs language-javascript\"><button class=\"copy-btn\">Copy</button><span class=\"hljs-keyword\">import</span> apiBasedTools <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./api-based-tools-complete.js&quot;</span>; <span class=\"hljs-comment\">// add complete at the end</span>\n</code></pre><p>Now you have all API endpoints available. Feel free to try very complex workflows and see how you do.</p>\n<p>For me, Claude 4 Sonnet did surprisingly well, only tripping up in a few cases where it shouldn&#39;t have after some extensive testing. But the smaller Qwen models were constantly getting it wrong.</p>\n","markdown":"\nSo let's start with what I would call the wrong way of doing MCP â€“ a one-to-one mapping of an API call to an MCP tool. Our issue tracker has about 15ish API calls, we're going to make each one into a tool. We'll get into why this could be a bad call but for now, it's the simplest conceptually to grasp so let's go do that. Or rather, I'm going to make you actually write the code for one and then let you copy/paste the rest. Feel free to do the whole thing, it's just a lot of code of doing the same thing.\n\nFirst, let's familiarize ourselves with the codebase in the Issues Tracker app. [The code is here on GitHub][issues], specifically the API documentation. Let's skip making the auth headers - it's too easy to prove my point. Getting an agent to successfully sign up and then manage a session just never worked for me, even when I was really trying to. So I made it so you can just nab a valid API key from the frontend. Sign up as a user and click \"copy API key\" from the header.\n\n> ðŸš¨ In the name of simplicity, I made it so every user can only ever have one valid API key at a time. If you click \"copy API key\" again, it'll generate a new one and copy it to your clipboard, meaning if you were using that API key elsewhere, it's now invalid. I didn't want to make a whole key management system.\n\nSo let's implement a tool to create issues.\n\n```javascript\nimport { z } from \"zod\";\n\nexport default function apiBasedTools(server) {\n  const API_BASE_URL = process.env.API_BASE_URL || \"http://localhost:3000/api\";\n\n  // Helper function to make HTTP requests\n  async function makeRequest(method, url, data = null, options = {}) {\n    const config = {\n      method,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...options.headers,\n      },\n    };\n\n    // Merge other options except headers (which we already handled)\n    const { headers: _, ...otherOptions } = options;\n    Object.assign(config, otherOptions);\n\n    if (data) {\n      config.body = JSON.stringify(data);\n    }\n\n    try {\n      const response = await fetch(url, config);\n      const result = await response.text();\n\n      let jsonResult;\n      try {\n        jsonResult = JSON.parse(result);\n      } catch {\n        jsonResult = result;\n      }\n\n      return {\n        status: response.status,\n        data: jsonResult,\n        headers: Object.fromEntries(response.headers.entries()),\n      };\n    } catch (error) {\n      return {\n        status: 0,\n        error: error.message,\n      };\n    }\n  }\n  server.registerTool(\n    \"issues-create\",\n    {\n      title: \"Create Issue\",\n      description: \"Create a new issue\",\n      inputSchema: {\n        title: z.string().describe(\"Issue title\"),\n        description: z.string().optional().describe(\"Issue description\"),\n        status: z\n          .enum([\"not_started\", \"in_progress\", \"done\"])\n          .optional()\n          .describe(\"Issue status\"),\n        priority: z\n          .enum([\"low\", \"medium\", \"high\", \"urgent\"])\n          .optional()\n          .describe(\"Issue priority\"),\n        assigned_user_id: z.string().optional().describe(\"Assigned user ID\"),\n        tag_ids: z.array(z.number()).optional().describe(\"Array of tag IDs\"),\n        apiKey: z.string().describe(\"API key for authentication\"),\n      },\n    },\n    async (params) => {\n      const { apiKey, ...issueData } = params;\n\n      const result = await makeRequest(\n        \"POST\",\n        `${API_BASE_URL}/issues`,\n        issueData,\n        { headers: { \"x-api-key\": apiKey } }\n      );\n\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: JSON.stringify(result, null, 2),\n          },\n        ],\n      };\n    }\n  );\n}\n```\n\nPretty straight forward. The zod types both make it very readable to use and it's what the LLM is going to use to decide what to put where. Let's add one more to list all tags.\n\nWe made this into a function that we can then import into our main.js and use. So back there and add this\n\n```javascript\n// at top\nimport apiBasedTools from \"./api-based-tools.js\";\n\n// under new McpServer\napiBasedTools(server);\n```\n\nMake sure you've added this MCP server to your Claude Desktop / Tome, restart it, and then try the prompt\n\n```\nCreate a new issue in my issue tracker that says \"Add Google login to my app\", mark it as in progress, and mark it as medium priority. Here is my API key: <YOUR API KEY>\n```\n\nOkay, let's take it a step further. Let's say we want to be able to add tags to it. Right now if you say \"mark it as a bug\" it will try to put \"bug\" as the tag ID but the tag ID is a number. So the user either needs to know that \"bug\" is tag ID ## or it just won't work. Let's add a tool for that.\n\nAdd this tool.\n\n```javascript\nserver.registerTool(\n  \"tags-list\",\n  {\n    title: \"List Tags\",\n    description: \"Get all available tags\",\n    inputSchema: {\n      apiKey: z.string().describe(\"API key for authentication\"),\n    },\n  },\n  async ({ apiKey }) => {\n    const result = await makeRequest(\"GET\", `${API_BASE_URL}/tags`, null, {\n      headers: { \"x-api-key\": apiKey },\n    });\n\n    return {\n      content: [\n        {\n          type: \"text\",\n          text: JSON.stringify(result, null, 2),\n        },\n      ],\n    };\n  }\n);\n```\n\nNow try\n\n```\nCreate a new issue in my issue tracker that says \"Add Microsoft login to my app\", mark it as not started, and mark it as urgent priority. Add the tags frontend and feature. Here is my API key: <YOUR API KEY>\n```\n\nNow, if you're using Claude Desktop, this will probably work. If you're using Qwen3:0.6B, well, flip a coin. I've had a hard time to get the smallest Qwen 3 model to do anything more than one step.\n\nOnce you feel okay with that, go ahead and change the import in main.js to import from the complete file\n\n```javascript\nimport apiBasedTools from \"./api-based-tools-complete.js\"; // add complete at the end\n```\n\nNow you have all API endpoints available. Feel free to try very complex workflows and see how you do.\n\nFor me, Claude 4 Sonnet did surprisingly well, only tripping up in a few cases where it shouldn't have after some extensive testing. But the smaller Qwen models were constantly getting it wrong.\n\n[issues]: https://github.com/btholt/mcp-issue-tracker?tab=readme-ov-file#api-documentation\n","slug":"api-based-tools","title":"Api Based Tools","section":"Our Project","icon":"screwdriver-wrench","filePath":"/home/runner/work/complete-intro-to-mcp/complete-intro-to-mcp/lessons/05-our-project/B-api-based-tools.md","nextSlug":"/lessons/our-project/jobs-based-tools","prevSlug":"/lessons/our-project/mcp-server-design"}},"__N_SSG":true}