{"pageProps":{"post":{"attributes":{"title":"Streamable HTTP","description":"Brian Holt walks you through building a Streamable HTTP MCP server in Node.js with Express, using a single /mcp endpoint and UUID-based sessions for client-server communication. The guide contrasts streamable HTTP with SSEs, demonstrates a concrete MCP setup (POST for client messages, GET for server messages, DELETE to end sessions), and covers scalability and security considerations plus inspector usage.","keywords":["MCP","Model Context Protocol","Streamable HTTP","Node.js","Express","session management"]},"html":"<p>Mark my words, there is about to be a Cambrian explosion of MCP server frameworks for Node.js that will handle a lot of this plumbing for you. But there isn&#39;t yet so we&#39;re going to have to do some manual housekeeping of session data. We&#39;re also not going to implement this in the most scalable way, but I&#39;ll leave that as an exercise to you to do.</p>\n<p>So let&#39;s talk about how streamable HTTP is different than SSEs. For one, there&#39;s just the one endpoint - you don&#39;t have to GET to one and POST to the other.</p>\n<p><img src=\"/images/streamable.png\" alt=\"Streamable HTTP diagram\"></p>\n<p>The topography of handshakes here is a bit more complicated but at the end you get a resumable session, one endpoint to deal with instead of two, and a server that can be stateless as long you architect it well.</p>\n<p>But yeah, the key here is that the server gives the session a UUID as a session ID and then the client refers to that using an HTTP header to make sure that the server and client both understand the ongoing context. That&#39;s really it. The idea of SSEs still happens inside of this, but it&#39;s only part of the architecture instead of all of it.</p>\n<p>We&#39;re going to implement our MCP main.js again but instead in <code>streamable.js</code> and using Express as our Node.js server. Express is chosen because we really just need minimal HTTP helpers and it&#39;s the one everyone gets. You can use Fastify, Next.js or whatever you want here.</p>\n<pre><code class=\"hljs language-bash\"><button class=\"copy-btn\">Copy</button>npm i express\n</code></pre><pre><code class=\"hljs language-javascript\"><button class=\"copy-btn\">Copy</button><span class=\"hljs-keyword\">import</span> express <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;express&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { randomUUID } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;node:crypto&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">McpServer</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@modelcontextprotocol/sdk/server/mcp.js&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">StreamableHTTPServerTransport</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@modelcontextprotocol/sdk/server/streamableHttp.js&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { isInitializeRequest } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@modelcontextprotocol/sdk/types.js&quot;</span>;\n<span class=\"hljs-keyword\">import</span> path <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;path&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { fileURLToPath } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;url&quot;</span>;\n<span class=\"hljs-keyword\">import</span> jobsBasedTools <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./jobs-based-tools.js&quot;</span>;\n\n<span class=\"hljs-keyword\">const</span> __filename = <span class=\"hljs-title function_\">fileURLToPath</span>(<span class=\"hljs-keyword\">import</span>.<span class=\"hljs-property\">meta</span>.<span class=\"hljs-property\">url</span>);\n<span class=\"hljs-keyword\">const</span> __dirname = path.<span class=\"hljs-title function_\">dirname</span>(__filename);\n\n<span class=\"hljs-keyword\">const</span> app = <span class=\"hljs-title function_\">express</span>();\napp.<span class=\"hljs-title function_\">use</span>(express.<span class=\"hljs-title function_\">json</span>());\n\n<span class=\"hljs-comment\">// Map to store transports by session ID</span>\n<span class=\"hljs-keyword\">const</span> transports = {};\n\n<span class=\"hljs-comment\">// Function to create a new MCP server instance</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createMcpServer</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">const</span> server = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">McpServer</span>({\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;issues-tracker-server&quot;</span>,\n    <span class=\"hljs-attr\">version</span>: <span class=\"hljs-string\">&quot;1.0.0&quot;</span>,\n  });\n\n  <span class=\"hljs-comment\">// Register jobs-based tools</span>\n  <span class=\"hljs-title function_\">jobsBasedTools</span>(server);\n\n  <span class=\"hljs-keyword\">return</span> server;\n}\n\n<span class=\"hljs-comment\">// Handle POST requests for client-to-server communication</span>\napp.<span class=\"hljs-title function_\">post</span>(<span class=\"hljs-string\">&quot;/mcp&quot;</span>, <span class=\"hljs-title function_\">async</span> (req, res) =&gt; {\n  <span class=\"hljs-comment\">// Check for existing session ID</span>\n  <span class=\"hljs-keyword\">const</span> sessionId = req.<span class=\"hljs-property\">headers</span>[<span class=\"hljs-string\">&quot;mcp-session-id&quot;</span>];\n  <span class=\"hljs-keyword\">let</span> transport;\n\n  <span class=\"hljs-keyword\">if</span> (sessionId &amp;&amp; transports[sessionId]) {\n    <span class=\"hljs-comment\">// Reuse existing transport</span>\n    transport = transports[sessionId];\n  } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (!sessionId &amp;&amp; <span class=\"hljs-title function_\">isInitializeRequest</span>(req.<span class=\"hljs-property\">body</span>)) {\n    <span class=\"hljs-comment\">// New initialization request</span>\n    transport = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">StreamableHTTPServerTransport</span>({\n      <span class=\"hljs-attr\">sessionIdGenerator</span>: <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-title function_\">randomUUID</span>(),\n      <span class=\"hljs-attr\">onsessioninitialized</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">sessionId</span>) =&gt;</span> {\n        <span class=\"hljs-comment\">// Store the transport by session ID</span>\n        transports[sessionId] = transport;\n      },\n      <span class=\"hljs-comment\">// DNS rebinding protection is disabled for MCP Inspector compatibility</span>\n      <span class=\"hljs-attr\">enableDnsRebindingProtection</span>: <span class=\"hljs-literal\">false</span>,\n    });\n\n    <span class=\"hljs-comment\">// Clean up transport when closed</span>\n    transport.<span class=\"hljs-property\">onclose</span> = <span class=\"hljs-function\">() =&gt;</span> {\n      <span class=\"hljs-keyword\">if</span> (transport.<span class=\"hljs-property\">sessionId</span>) {\n        <span class=\"hljs-keyword\">delete</span> transports[transport.<span class=\"hljs-property\">sessionId</span>];\n      }\n    };\n\n    <span class=\"hljs-keyword\">const</span> server = <span class=\"hljs-title function_\">createMcpServer</span>();\n\n    <span class=\"hljs-comment\">// Connect to the MCP server</span>\n    <span class=\"hljs-keyword\">await</span> server.<span class=\"hljs-title function_\">connect</span>(transport);\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// Invalid request</span>\n    res.<span class=\"hljs-title function_\">status</span>(<span class=\"hljs-number\">400</span>).<span class=\"hljs-title function_\">json</span>({\n      <span class=\"hljs-attr\">jsonrpc</span>: <span class=\"hljs-string\">&quot;2.0&quot;</span>,\n      <span class=\"hljs-attr\">error</span>: {\n        <span class=\"hljs-attr\">code</span>: -<span class=\"hljs-number\">32000</span>,\n        <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">&quot;Bad Request: No valid session ID provided&quot;</span>,\n      },\n      <span class=\"hljs-attr\">id</span>: <span class=\"hljs-literal\">null</span>,\n    });\n    <span class=\"hljs-keyword\">return</span>;\n  }\n\n  <span class=\"hljs-comment\">// Handle the request</span>\n  <span class=\"hljs-keyword\">await</span> transport.<span class=\"hljs-title function_\">handleRequest</span>(req, res, req.<span class=\"hljs-property\">body</span>);\n});\n\n<span class=\"hljs-comment\">// Reusable handler for GET and DELETE requests</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">handleSessionRequest</span> = <span class=\"hljs-keyword\">async</span> (<span class=\"hljs-params\">req, res</span>) =&gt; {\n  <span class=\"hljs-keyword\">const</span> sessionId = req.<span class=\"hljs-property\">headers</span>[<span class=\"hljs-string\">&quot;mcp-session-id&quot;</span>];\n  <span class=\"hljs-keyword\">if</span> (!sessionId || !transports[sessionId]) {\n    res.<span class=\"hljs-title function_\">status</span>(<span class=\"hljs-number\">400</span>).<span class=\"hljs-title function_\">send</span>(<span class=\"hljs-string\">&quot;Invalid or missing session ID&quot;</span>);\n    <span class=\"hljs-keyword\">return</span>;\n  }\n\n  <span class=\"hljs-keyword\">const</span> transport = transports[sessionId];\n  <span class=\"hljs-keyword\">await</span> transport.<span class=\"hljs-title function_\">handleRequest</span>(req, res);\n};\n\n<span class=\"hljs-comment\">// Handle GET requests for server-to-client notifications via SSE</span>\napp.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">&quot;/mcp&quot;</span>, handleSessionRequest);\n\n<span class=\"hljs-comment\">// Handle DELETE requests for session termination</span>\napp.<span class=\"hljs-title function_\">delete</span>(<span class=\"hljs-string\">&quot;/mcp&quot;</span>, handleSessionRequest);\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-variable constant_\">PORT</span> = <span class=\"hljs-number\">3100</span>;\napp.<span class=\"hljs-title function_\">listen</span>(<span class=\"hljs-variable constant_\">PORT</span>, <span class=\"hljs-function\">() =&gt;</span> {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`MCP Streamable HTTP Server listening on port <span class=\"hljs-subst\">${PORT}</span>`</span>);\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`Server endpoint: http://localhost:<span class=\"hljs-subst\">${PORT}</span>/mcp`</span>);\n});\n</code></pre><ul>\n<li>Every session needs a UUID to keep track of which session is ongoing. I&#39;m just using node:crypto for this and JS object to keep track of it. This wouldn&#39;t scale - every client would need to hit the same client which makes it hard to scale. You&#39;d probably use Redis or something to share state amongst stateless servers to scale this better.</li>\n<li>We need to handle POST for client-to-server messages, GET for server-to-client messages, and DELETE for ending sessions.</li>\n<li>I turned off the DNS rebinding protection so we can use the MCP inspector but this is something you&#39;d leave on in prod. Bascially you don&#39;t want people to be able to jack other people&#39;s sessions if they&#39;re able to guess the UUID, that would be a huge vulnerability. But locally it doesn&#39;t matter.</li>\n<li>Beyond this, this should just look like a normal ol&#39; web server which it is. We definitely could have (and probably should have) just built this into our backend.</li>\n</ul>\n<p>Let&#39;s try it now.</p>\n<pre><code><button class=\"copy-btn\">Copy</button>npx @modelcontextprotocol/inspector\n</code></pre><p>Then in the UI put in <code>localhost:3100/mcp</code> to connect to your server. Make sure that you either click the link directly from the CLI or that you bring with you the session token. This is just so one or thing on your network can jack your local MCP session and do weird stuff. Again, it&#39;s a powerful tool so we need security to make sure it works okay!</p>\n<p>Now you should see our three jobs-based tools in the inspector.</p>\n<p>So what are the limitations here?</p>\n<ul>\n<li>Obviously we can&#39;t just shell out CLI commands - we&#39;re constrained to only what we can do on our server and pass back to the user.</li>\n<li>We have to worry a lot more about security - we don&#39;t want to leak other users&#39; data because we did something wrong.</li>\n</ul>\n<p>If you want more depth here, <a href=\"https://brightdata.com/blog/ai/sse-vs-streamable-http\">I liked BrightData&#39;s blog post on it</a></p>\n","markdown":"\nMark my words, there is about to be a Cambrian explosion of MCP server frameworks for Node.js that will handle a lot of this plumbing for you. But there isn't yet so we're going to have to do some manual housekeeping of session data. We're also not going to implement this in the most scalable way, but I'll leave that as an exercise to you to do.\n\nSo let's talk about how streamable HTTP is different than SSEs. For one, there's just the one endpoint - you don't have to GET to one and POST to the other.\n\n![Streamable HTTP diagram](/images/streamable.png)\n\nThe topography of handshakes here is a bit more complicated but at the end you get a resumable session, one endpoint to deal with instead of two, and a server that can be stateless as long you architect it well.\n\nBut yeah, the key here is that the server gives the session a UUID as a session ID and then the client refers to that using an HTTP header to make sure that the server and client both understand the ongoing context. That's really it. The idea of SSEs still happens inside of this, but it's only part of the architecture instead of all of it.\n\nWe're going to implement our MCP main.js again but instead in `streamable.js` and using Express as our Node.js server. Express is chosen because we really just need minimal HTTP helpers and it's the one everyone gets. You can use Fastify, Next.js or whatever you want here.\n\n```bash\nnpm i express\n```\n\n```javascript\nimport express from \"express\";\nimport { randomUUID } from \"node:crypto\";\nimport { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport { StreamableHTTPServerTransport } from \"@modelcontextprotocol/sdk/server/streamableHttp.js\";\nimport { isInitializeRequest } from \"@modelcontextprotocol/sdk/types.js\";\nimport path from \"path\";\nimport { fileURLToPath } from \"url\";\nimport jobsBasedTools from \"./jobs-based-tools.js\";\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\nconst app = express();\napp.use(express.json());\n\n// Map to store transports by session ID\nconst transports = {};\n\n// Function to create a new MCP server instance\nfunction createMcpServer() {\n  const server = new McpServer({\n    name: \"issues-tracker-server\",\n    version: \"1.0.0\",\n  });\n\n  // Register jobs-based tools\n  jobsBasedTools(server);\n\n  return server;\n}\n\n// Handle POST requests for client-to-server communication\napp.post(\"/mcp\", async (req, res) => {\n  // Check for existing session ID\n  const sessionId = req.headers[\"mcp-session-id\"];\n  let transport;\n\n  if (sessionId && transports[sessionId]) {\n    // Reuse existing transport\n    transport = transports[sessionId];\n  } else if (!sessionId && isInitializeRequest(req.body)) {\n    // New initialization request\n    transport = new StreamableHTTPServerTransport({\n      sessionIdGenerator: () => randomUUID(),\n      onsessioninitialized: (sessionId) => {\n        // Store the transport by session ID\n        transports[sessionId] = transport;\n      },\n      // DNS rebinding protection is disabled for MCP Inspector compatibility\n      enableDnsRebindingProtection: false,\n    });\n\n    // Clean up transport when closed\n    transport.onclose = () => {\n      if (transport.sessionId) {\n        delete transports[transport.sessionId];\n      }\n    };\n\n    const server = createMcpServer();\n\n    // Connect to the MCP server\n    await server.connect(transport);\n  } else {\n    // Invalid request\n    res.status(400).json({\n      jsonrpc: \"2.0\",\n      error: {\n        code: -32000,\n        message: \"Bad Request: No valid session ID provided\",\n      },\n      id: null,\n    });\n    return;\n  }\n\n  // Handle the request\n  await transport.handleRequest(req, res, req.body);\n});\n\n// Reusable handler for GET and DELETE requests\nconst handleSessionRequest = async (req, res) => {\n  const sessionId = req.headers[\"mcp-session-id\"];\n  if (!sessionId || !transports[sessionId]) {\n    res.status(400).send(\"Invalid or missing session ID\");\n    return;\n  }\n\n  const transport = transports[sessionId];\n  await transport.handleRequest(req, res);\n};\n\n// Handle GET requests for server-to-client notifications via SSE\napp.get(\"/mcp\", handleSessionRequest);\n\n// Handle DELETE requests for session termination\napp.delete(\"/mcp\", handleSessionRequest);\n\nconst PORT = 3100;\napp.listen(PORT, () => {\n  console.log(`MCP Streamable HTTP Server listening on port ${PORT}`);\n  console.log(`Server endpoint: http://localhost:${PORT}/mcp`);\n});\n```\n\n- Every session needs a UUID to keep track of which session is ongoing. I'm just using node:crypto for this and JS object to keep track of it. This wouldn't scale - every client would need to hit the same client which makes it hard to scale. You'd probably use Redis or something to share state amongst stateless servers to scale this better.\n- We need to handle POST for client-to-server messages, GET for server-to-client messages, and DELETE for ending sessions.\n- I turned off the DNS rebinding protection so we can use the MCP inspector but this is something you'd leave on in prod. Bascially you don't want people to be able to jack other people's sessions if they're able to guess the UUID, that would be a huge vulnerability. But locally it doesn't matter.\n- Beyond this, this should just look like a normal ol' web server which it is. We definitely could have (and probably should have) just built this into our backend.\n\nLet's try it now.\n\n```\nnpx @modelcontextprotocol/inspector\n```\n\nThen in the UI put in `localhost:3100/mcp` to connect to your server. Make sure that you either click the link directly from the CLI or that you bring with you the session token. This is just so one or thing on your network can jack your local MCP session and do weird stuff. Again, it's a powerful tool so we need security to make sure it works okay!\n\nNow you should see our three jobs-based tools in the inspector.\n\nSo what are the limitations here?\n\n- Obviously we can't just shell out CLI commands - we're constrained to only what we can do on our server and pass back to the user.\n- We have to worry a lot more about security - we don't want to leak other users' data because we did something wrong.\n\nIf you want more depth here, [I liked BrightData's blog post on it][brightdata]\n\n[brightdata]: https://brightdata.com/blog/ai/sse-vs-streamable-http\n","slug":"streamable-http","title":"Streamable HTTP","section":"SSEs and Streaming HTML","icon":"bars-staggered","filePath":"/home/runner/work/complete-intro-to-mcp/complete-intro-to-mcp/lessons/06-sses-and-streaming-html/B-streamable-http.md","nextSlug":"/lessons/vibes/lets-vibe-code","prevSlug":"/lessons/sses-and-streaming-html/server-side-events"}},"__N_SSG":true}