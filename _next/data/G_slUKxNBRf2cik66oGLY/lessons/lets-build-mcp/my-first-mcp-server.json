{"pageProps":{"post":{"attributes":{"title":"My First MCP Server","description":"Brian Holt guides you through building a local MCP server (Model Context Protocol) using stdio transport, registering an addition tool with Zod validation, and testing via CLI with JSON RPC 2.0. This hands-on example uses the @modelcontextprotocol/sdk in Node.js to show how MCP servers communicate over standard input/output, laying the groundwork for future SSE-based transports and AI tool integration.","keywords":["MCP server","Model Context Protocol","JSON RPC 2.0","StdioServerTransport","Node.js","Zod","Brian Holt"]},"html":"<p>Without further ado, let&#39;s make our first MCP server!</p>\n<blockquote>\n<p>We are going to make a local MCP server first, the &quot;old way&quot;, or the STDIO way, however you want to label it. We&#39;ll do the SSE or the remote way later in the course.</p>\n</blockquote>\n<p>At its most simple, an MCP server is just that, a server. It runs a locally running server that allows you to feed it information via <a href=\"https://btholt.github.io/complete-intro-to-linux-and-the-cli/streams-and-pipes\">standard IO</a> an LLM can call. In truth, MCP servers are at their core super simple, and you&#39;ll probably think it&#39;s silly that we wrap them in such a mystique (it is silly.)</p>\n<p>It&#39;s a bit of a specialized server as it expects certain input to return certain shapes of responses, but beyond that it&#39;s a bog-standard server, so much so that you can literally write your MCP servers in plain Node.js/Bun/Python/whatever.</p>\n<p>We&#39;ll be using <code>@modelcontextprotocol/sdk</code> which is a little toolkit that helps you get started. It&#39;s not totally necessary as the MCP protocol is fairly simple but it just helps us make sure that everything gets tracked the right way.</p>\n<p>So create a new directory, do <code>npm init -y</code> and run <code>npm install @modelcontextprotocol/sdk</code>. In a new file called mcp.js, add</p>\n<pre><code class=\"hljs language-javascript\"><button class=\"copy-btn\">Copy</button><span class=\"hljs-keyword\">import</span> {\n  <span class=\"hljs-title class_\">McpServer</span>,\n  <span class=\"hljs-title class_\">ResourceTemplate</span>,\n} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@modelcontextprotocol/sdk/server/mcp.js&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">StdioServerTransport</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@modelcontextprotocol/sdk/server/stdio.js&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { z } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;zod&quot;</span>;\n\n<span class=\"hljs-comment\">// Create an MCP server</span>\n<span class=\"hljs-keyword\">const</span> server = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">McpServer</span>({\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;add-server&quot;</span>,\n  <span class=\"hljs-attr\">version</span>: <span class=\"hljs-string\">&quot;1.0.0&quot;</span>,\n});\n\n<span class=\"hljs-comment\">// Add an addition tool</span>\nserver.<span class=\"hljs-title function_\">registerTool</span>(\n  <span class=\"hljs-string\">&quot;add&quot;</span>,\n  {\n    <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">&quot;Addition Tool&quot;</span>,\n    <span class=\"hljs-attr\">description</span>: <span class=\"hljs-string\">&quot;Add two numbers&quot;</span>,\n    <span class=\"hljs-attr\">inputSchema</span>: { <span class=\"hljs-attr\">a</span>: z.<span class=\"hljs-title function_\">number</span>(), <span class=\"hljs-attr\">b</span>: z.<span class=\"hljs-title function_\">number</span>() },\n  },\n  <span class=\"hljs-title function_\">async</span> ({ a, b }) =&gt; {\n    <span class=\"hljs-keyword\">return</span> {\n        <span class=\"hljs-attr\">content</span>: [{ <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&quot;text&quot;</span>, <span class=\"hljs-attr\">text</span>: <span class=\"hljs-title class_\">String</span>(a + b) }],\n    }\n  }\n);\n\n<span class=\"hljs-comment\">// Start receiving messages on stdin and sending messages on stdout</span>\n<span class=\"hljs-keyword\">const</span> transport = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">StdioServerTransport</span>();\n<span class=\"hljs-keyword\">await</span> server.<span class=\"hljs-title function_\">connect</span>(transport);\n</code></pre><ul>\n<li>This is as simple an MCP server as you&#39;re going to find.</li>\n<li>It registers itself as an MCP server with the <code>new McpServer</code> instantiation</li>\n<li>We then add one tool to it, one that adds two numbers together. Obviously an LLM can do this but we&#39;re just going for simple here.</li>\n<li>We then specify the transport we&#39;re using is stdio, which is using bash&#39;s stdin to send info to the MCP server. SSE would be the other kind of transport, and we&#39;ll get to that.</li>\n<li>We&#39;re also using <a href=\"https://zod.dev/\">Zod</a> here. Zod is a validation library that&#39;s built TypeScript first. It&#39;s really useful as you can define what schemas are expected and it serves several purposes.<ul>\n<li>It tells the LLM in strong terms &quot;whatever you give here, it must pass this zod validation. LLMs do well with strong guidelines</li>\n<li>It&#39;s documentation for future you of what this tool call needs.</li>\n<li>It also allows you to add annotations that tell the LLM &quot;this variable named X expects Y type and in plain English, this variable is Z.&quot;</li>\n</ul>\n</li>\n</ul>\n<p>So try starting your server and you&#39;ll see it&#39;ll just do nothing. That&#39;s because you need to use stdin to send it commands! Let&#39;s try one.</p>\n<pre><code class=\"hljs language-bash\"><button class=\"copy-btn\">Copy</button><span class=\"hljs-comment\"># List available tools:</span>\n<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&#x27;{&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;id&quot;: 1, &quot;method&quot;: &quot;tools/list&quot;, &quot;params&quot;: {&quot;name&quot;: &quot;add&quot;, &quot;arguments&quot;: {}}}&#x27;</span> | node mcp.js | jq\n\n<span class=\"hljs-comment\"># Call a tool:</span>\n<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&#x27;{&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;id&quot;: 1, &quot;method&quot;: &quot;tools/call&quot;, &quot;params&quot;: {&quot;name&quot;: &quot;add&quot;, &quot;arguments&quot;: {&quot;a&quot;: 5, &quot;b&quot;: 3}}}&#x27;</span> | node mcp.js\n</code></pre><ul>\n<li><a href=\"https://jqlang.org/\">jq</a> is super helpful for processing JSON on the command line. It can do a lot more than pretty print but it&#39;s 99.99% of what I use it for</li>\n<li>You don&#39;t really need to know how to invoke your MCP server via the CLI - your LLM will do it for you. But it helpful for testing! I usually have an LLM write the CLI command for me anyway ♻️</li>\n<li>It&#39;s enough to know that you&#39;re calling the tools via stdin with a standard format. It passes that it wants to list available tools (which is how LLMs know what is available to use) and then it uses <code>tools/call</code> to actually invoke the tool. There&#39;s a lot more to MCP but frankly it&#39;s low level and really not needed to be known by you. But this is the protocol.</li>\n</ul>\n<h2>JSON RPC 2.0</h2>\n<p>You should see the MCP server respond with an answer of 8! This feels just like writing API endpoints, but the advantage here is that we get to give these tools to LLMs and they can call into code we generate for them. Let&#39;s talk a bit about JSON RPC 2.0 which is all this is. <a href=\"https://en.wikipedia.org/wiki/JSON-RPC\">JSON RPC</a> is ancient in computing terms with the first version of the spec coming out in 2005. The revised 2.0 version came out in 2010 and that&#39;s what this is using – we&#39;re not doing anything wild here, just relying on a very proven set of technology.</p>\n<p>So what <em>is</em> JSON RPC? You can think of it as an alternative to REST. With REST you call endpoints that are based around a thing - e.g. you call a PATCH to /users/123 to update user 123. Your URLs are based things and the semantics of manipulating those things. JSON RPC (and XML RPC before it) is based around calling remote functions - that&#39;s it. It&#39;s literally a remote procedure call. So in this we&#39;re just giving an MCP server direction on what procedures (or functions) we want them to do. That&#39;s it!</p>\n<p>Let&#39;s see it initialize itself!</p>\n<pre><code class=\"hljs language-bash\"><button class=\"copy-btn\">Copy</button><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&#x27;{&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;id&quot;: 1, &quot;method&quot;: &quot;initialize&quot;, &quot;params&quot;: {&quot;protocolVersion&quot;: &quot;2024-11-05&quot;, &quot;capabilities&quot;: {}, &quot;clientInfo&quot;: {&quot;name&quot;: &quot;test-client&quot;, &quot;version&quot;: &quot;1.0.0&quot;}}}&#x27;</span> | node mcp.js | jq\n</code></pre>","markdown":"\nWithout further ado, let's make our first MCP server!\n\n> We are going to make a local MCP server first, the \"old way\", or the STDIO way, however you want to label it. We'll do the SSE or the remote way later in the course.\n\nAt its most simple, an MCP server is just that, a server. It runs a locally running server that allows you to feed it information via [standard IO][stdio] an LLM can call. In truth, MCP servers are at their core super simple, and you'll probably think it's silly that we wrap them in such a mystique (it is silly.)\n\nIt's a bit of a specialized server as it expects certain input to return certain shapes of responses, but beyond that it's a bog-standard server, so much so that you can literally write your MCP servers in plain Node.js/Bun/Python/whatever.\n\nWe'll be using `@modelcontextprotocol/sdk` which is a little toolkit that helps you get started. It's not totally necessary as the MCP protocol is fairly simple but it just helps us make sure that everything gets tracked the right way.\n\nSo create a new directory, do `npm init -y` and run `npm install @modelcontextprotocol/sdk`. In a new file called mcp.js, add\n\n```javascript\nimport {\n  McpServer,\n  ResourceTemplate,\n} from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport { z } from \"zod\";\n\n// Create an MCP server\nconst server = new McpServer({\n  name: \"add-server\",\n  version: \"1.0.0\",\n});\n\n// Add an addition tool\nserver.registerTool(\n  \"add\",\n  {\n    title: \"Addition Tool\",\n    description: \"Add two numbers\",\n    inputSchema: { a: z.number(), b: z.number() },\n  },\n  async ({ a, b }) => {\n    return {\n        content: [{ type: \"text\", text: String(a + b) }],\n    }\n  }\n);\n\n// Start receiving messages on stdin and sending messages on stdout\nconst transport = new StdioServerTransport();\nawait server.connect(transport);\n```\n\n- This is as simple an MCP server as you're going to find.\n- It registers itself as an MCP server with the `new McpServer` instantiation\n- We then add one tool to it, one that adds two numbers together. Obviously an LLM can do this but we're just going for simple here.\n- We then specify the transport we're using is stdio, which is using bash's stdin to send info to the MCP server. SSE would be the other kind of transport, and we'll get to that.\n- We're also using [Zod][zod] here. Zod is a validation library that's built TypeScript first. It's really useful as you can define what schemas are expected and it serves several purposes.\n  - It tells the LLM in strong terms \"whatever you give here, it must pass this zod validation. LLMs do well with strong guidelines\n  - It's documentation for future you of what this tool call needs.\n  - It also allows you to add annotations that tell the LLM \"this variable named X expects Y type and in plain English, this variable is Z.\"\n\nSo try starting your server and you'll see it'll just do nothing. That's because you need to use stdin to send it commands! Let's try one.\n\n```bash\n# List available tools:\necho '{\"jsonrpc\": \"2.0\", \"id\": 1, \"method\": \"tools/list\", \"params\": {\"name\": \"add\", \"arguments\": {}}}' | node mcp.js | jq\n\n# Call a tool:\necho '{\"jsonrpc\": \"2.0\", \"id\": 1, \"method\": \"tools/call\", \"params\": {\"name\": \"add\", \"arguments\": {\"a\": 5, \"b\": 3}}}' | node mcp.js\n```\n\n- [jq][jq] is super helpful for processing JSON on the command line. It can do a lot more than pretty print but it's 99.99% of what I use it for\n- You don't really need to know how to invoke your MCP server via the CLI - your LLM will do it for you. But it helpful for testing! I usually have an LLM write the CLI command for me anyway ♻️\n- It's enough to know that you're calling the tools via stdin with a standard format. It passes that it wants to list available tools (which is how LLMs know what is available to use) and then it uses `tools/call` to actually invoke the tool. There's a lot more to MCP but frankly it's low level and really not needed to be known by you. But this is the protocol.\n\n## JSON RPC 2.0\n\nYou should see the MCP server respond with an answer of 8! This feels just like writing API endpoints, but the advantage here is that we get to give these tools to LLMs and they can call into code we generate for them. Let's talk a bit about JSON RPC 2.0 which is all this is. [JSON RPC][rpc] is ancient in computing terms with the first version of the spec coming out in 2005. The revised 2.0 version came out in 2010 and that's what this is using – we're not doing anything wild here, just relying on a very proven set of technology.\n\nSo what _is_ JSON RPC? You can think of it as an alternative to REST. With REST you call endpoints that are based around a thing - e.g. you call a PATCH to /users/123 to update user 123. Your URLs are based things and the semantics of manipulating those things. JSON RPC (and XML RPC before it) is based around calling remote functions - that's it. It's literally a remote procedure call. So in this we're just giving an MCP server direction on what procedures (or functions) we want them to do. That's it!\n\nLet's see it initialize itself!\n\n```bash\necho '{\"jsonrpc\": \"2.0\", \"id\": 1, \"method\": \"initialize\", \"params\": {\"protocolVersion\": \"2024-11-05\", \"capabilities\": {}, \"clientInfo\": {\"name\": \"test-client\", \"version\": \"1.0.0\"}}}' | node mcp.js | jq\n```\n\n[stdio]: https://btholt.github.io/complete-intro-to-linux-and-the-cli/streams-and-pipes\n[rpc]: https://en.wikipedia.org/wiki/JSON-RPC\n[jq]: https://jqlang.org/\n[zod]: https://zod.dev/\n","slug":"my-first-mcp-server","title":"My First MCP Server","section":"Let's Build an MCP Server","icon":"file-code","filePath":"/home/runner/work/complete-intro-to-mcp/complete-intro-to-mcp/lessons/04-lets-build-mcp/A-my-first-mcp-server.md","nextSlug":"/lessons/lets-build-mcp/using-our-first-mcp-server","prevSlug":"/lessons/setup-mcp-clients/other-clients"}},"__N_SSG":true}